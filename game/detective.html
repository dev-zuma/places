<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Worldwide Chase - Investigation File</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Pattern Recognition Styling */
        .evidence-content.pattern-recognition {
            font-size: 16px; /* Normal font size for the container */
            text-align: center;
            line-height: 1.4;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 2px solid #6c757d;
            margin: 10px 0;
        }
        
        /* Pattern label with normal font size */
        .evidence-content.pattern-recognition .pattern-label {
            font-size: 16px;
            line-height: 1.4;
            margin-bottom: 10px;
            color: #495057;
        }
        
        /* Large emoji pattern within pattern recognition */
        .evidence-content.pattern-recognition .emoji-pattern {
            font-size: 48px;
            line-height: 1.2;
            margin: 10px 0;
        }
        
        /* Hover effect for pattern recognition */
        .evidence-content.pattern-recognition:hover {
            transform: scale(1.05);
            transition: transform 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Loading State -->
        <div class="loading-container" id="loadingContainer">
            <div class="loading-spinner"></div>
            <h3>Loading Case File...</h3>
            <p>Gathering evidence and witness reports</p>
        </div>

        <!-- Error State -->
        <div class="error-container hidden" id="errorContainer">
            <h2>Case Not Found</h2>
            <p>The requested case file could not be located in our database.</p>
            <button class="back-button" onclick="window.location.href = 'index.html'">
                ‚Üê Back to Chase Gallery
            </button>
        </div>

        <!-- Main Game Interface (initially hidden) -->
        <div id="gameInterface" class="hidden">
            <!-- Detective Header Container (injected by detective-header.js) -->
            <div id="detective-header-container"></div>

            <!-- Turn Indicator (modified for V2) -->
            <div class="turn-indicator-container">
                <div class="turn-indicator v2">
                    <div class="turn-progress-line">
                        <div class="turn-progress-fill" id="progressFill"></div>
                    </div>
                    <div class="turn-section crime-scenes">
                        <div class="turn-dot active turn-1" id="turn1">1</div>
                        <div class="turn-dot no-image" id="turn2">2</div>
                        <div class="turn-dot" id="turn3">3</div>
                        <div class="turn-dot no-image" id="turn4">4</div>
                        <div class="turn-dot" id="turn5">5</div>
                    </div>
                    <div class="turn-section final-location hidden" id="finalLocationSection">
                        <div class="turn-dot" id="turn6">6</div>
                        <div class="turn-dot" id="turn7">7</div>
                    </div>
                </div>
            </div>

            <!-- Detective File Tabs -->
            <div class="detective-tabs">
                <div class="tabs-left">
                    <button class="tab-button active" id="caseDetailsTab" onclick="switchTab('caseDetails')">
                        Case Details
                    </button>
                    <button class="tab-button" id="investigationTab" onclick="switchTab('investigation')">
                        Investigation Journal
                    </button>
                    <button class="tab-button" id="answersTab" onclick="switchTab('answers')">
                        Check Answers
                    </button>
                </div>
                <div class="tabs-right">
                    <div class="timer-display">
                        <div class="timer-label">TIME</div>
                        <div class="timer-value" id="timerValue">00:00</div>
                    </div>
                </div>
            </div>

            <!-- Tab Content -->
            <div class="tab-content">
                <!-- Case Details Tab -->
                <div class="tab-panel active" id="caseDetailsPanel">
                    <div class="case-file-layout">
                        <!-- Villain Profile -->
                        <div class="villain-profile">
                            <div class="villain-mugshot">
                                <img id="villainPortrait" alt="" class="villain-portrait clickable" onclick="showVillainModal()">
                                <div class="mugshot-label">SUSPECT</div>
                            </div>
                            <div class="villain-info">
                                <h3 id="villainName"></h3>
                                <p class="villain-title" id="villainTitle"></p>
                            </div>
                        </div>

                        <!-- Case Summary -->
                        <div class="case-section crime-summary">
                            <h4>Case Summary</h4>
                            <p id="crimeSummary"></p>
                        </div>
                        
                        <!-- Investigation Journal Button -->
                        <div class="case-section investigation-button-section">
                            <button class="investigation-journal-button" onclick="switchTab('investigation')">
                                üïµÔ∏è Open Investigation Journal
                            </button>
                            <p class="investigation-button-hint">Review evidence and check your answers</p>
                        </div>
                        
                    </div>
                </div>

                <!-- Investigation Journal Tab -->
                <div class="tab-panel" id="investigationPanel">
                    <div class="clues-board">
                        <div class="clues-header">
                            <h3>Investigation Journal</h3>
                            <p class="clues-subtitle">Evidence and discoveries from your investigation</p>
                            <div class="view-selector">
                                <select class="view-dropdown" id="viewDropdown" onchange="switchView()">
                                    <option value="distances" id="distancesOption" style="display: none;">üìè Distances</option>
                                    <option value="location1">üèôÔ∏è City 1</option>
                                    <option value="location2">üèôÔ∏è City 2</option>
                                    <option value="location3">üèôÔ∏è City 3</option>
                                    <option value="final" id="finalOption" style="display: none;">üéØ Final Location</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Distances View -->
                        <div class="evidence-view" id="distancesView">
                            <div class="distances-content" id="distancesContent">
                                <!-- Distance and timeline content will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Location Views -->
                        <div class="evidence-view hidden" id="location1View">
                            <div class="location-evidence" id="location1Evidence">
                                <!-- City 1 clues will be populated here -->
                            </div>
                        </div>
                        
                        <div class="evidence-view hidden" id="location2View">
                            <div class="location-evidence" id="location2Evidence">
                                <!-- City 2 clues will be populated here -->
                            </div>
                        </div>
                        
                        <div class="evidence-view hidden" id="location3View">
                            <div class="location-evidence" id="location3Evidence">
                                <!-- City 3 clues will be populated here -->
                            </div>
                        </div>
                        
                        <div class="evidence-view hidden" id="finalView">
                            <div class="final-evidence" id="finalEvidence">
                                <!-- Final location clues will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Check Answers Tab -->
                <div class="tab-panel" id="answersPanel">
                    <div class="game-area">
                        <!-- Description -->
                        <div class="tab-description">
                            <p>Enter location names based on evidence. Check Investigation Journal for clues and photos.</p>
                        </div>
                        
                        <!-- Crime Scene Phase -->
                        <div class="answer-phase" id="crimeScenePhase">
                            <div id="crimeLocationInputs">
                                <!-- Crime scene letter box inputs will be generated dynamically -->
                            </div>
                        </div>

                        <!-- Final Location Phase (hidden initially) -->
                        <div class="answer-phase hidden" id="finalLocationPhase">
                            <div class="phase-unlock-message">
                                <h3>üéØ Capture the Suspect!</h3>
                                <p id="finalObjectiveDescription">The suspect's final location has been revealed. Check Investigation Journal for new clues.</p>
                            </div>
                            <div class="final-location-container" id="finalLocationContainer">
                                <!-- Final location letter boxes will be generated dynamically -->
                            </div>
                        </div>

                        <!-- Case Complete (hidden initially) -->
                        <div class="case-complete hidden" id="caseComplete">
                            <h3>üéâ Case Solved!</h3>
                            <div class="completion-message" id="completionMessage"></div>
                            <div class="final-interesting-fact" id="finalFact"></div>
                            <div class="game-stats">
                                <div class="stat-item">
                                    <label>Time Taken:</label>
                                    <span id="finalTime"></span>
                                </div>
                            </div>
                        </div>

                        <!-- Action Button -->
                        <div class="action-button-container">
                            <button class="action-button turn-1" id="actionButton" onclick="submitEvidence()">
                                Turn 1 Check
                            </button>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- Image Modal -->
    <div id="imageModal" class="image-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
            <div class="modal-header" id="modalHeader">Evidence Photo</div>
            <img id="modalImage" class="modal-image" src="" alt="Evidence">
        </div>
    </div>

    <script>
        let currentCase = null;
        let gameData = null;
        let currentTurn = 1;
        let activeTab = 'caseDetails';
        let gameStartTime = null;
        let gameTimer = 0;
        let timerInterval = null;
        let cluesViewMode = 'timeline';
        let gameState = 'investigating_crimes'; // investigating_crimes, crimes_solved, final_investigation, case_complete

        // V2 specific variables
        let crimeSceneAnswers = { location1: false, location2: false, location3: false };
        let finalLocationAnswer = false;
        let gameScore = 0;
        let correctLocations = [false, false, false, false]; // Track all 4 locations

        // Load case data on page load
        document.addEventListener('DOMContentLoaded', async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const caseId = urlParams.get('case') || urlParams.get('caseId');
            
            console.log('URL params:', window.location.search);
            console.log('Case ID found:', caseId);
            
            if (!caseId) {
                showError('No case ID provided');
                return;
            }
            
            await loadV2Case(caseId);
        });

        async function loadV2Case(caseId) {
            try {
                const response = await fetch(`/api/v2/games/${caseId}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch V2 game');
                }
                
                currentCase = await response.json();
                
                if (!currentCase) {
                    showError('V2 Game not found');
                    return;
                }
                
                initializeV2Game();
                
            } catch (error) {
                console.error('Error loading V2 case:', error);
                showError('Failed to load V2 case data');
            }
        }

        function initializeV2Game() {
            // Hide loading and error states, show game
            document.getElementById('loadingContainer').classList.add('hidden');
            document.getElementById('loadingContainer').style.display = 'none';
            
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.classList.add('hidden');
            errorContainer.classList.remove('show-flex');
            errorContainer.style.display = 'none';
            
            document.getElementById('gameInterface').classList.remove('hidden');
            document.getElementById('gameInterface').classList.add('show-flex', 'flex-column', 'flex-height');
            
            // Reset diagram flag
            window.turn1DiagramShown = false;
            window.connectionWebShown = false;
            
            // Set gameData for modals
            gameData = currentCase;
            
            // Populate case details
            document.getElementById('villainPortrait').src = currentCase.villainImageUrl || '/game/wwc-logo.png';
            document.getElementById('villainPortrait').alt = currentCase.villainName;
            document.getElementById('villainName').textContent = currentCase.villainName;
            document.getElementById('villainTitle').textContent = currentCase.villainTitle;
            document.getElementById('crimeSummary').textContent = currentCase.crimeSummary;
            
            // Set case title in header
            const caseTitleElement = document.getElementById('caseTitle');
            if (caseTitleElement) {
                caseTitleElement.textContent = currentCase.caseTitle || 'Investigation Case';
            }
            
            // Generate location inputs
            generateV2LocationInputs();
            
            // Initialize game state
            updateV2TurnDisplay();
            
            // Start the timer
            gameStartTime = new Date();
            startElapsedTimer();
            
            // Initialize with Turn 1 clues
            displayV2Turn(1);
        }

        function generateV2LocationInputs() {
            const container = document.getElementById('crimeLocationInputs');
            container.innerHTML = '';
            
            // Create letter box inputs for crime scene locations (using actual location names)
            currentCase.locationsV2.forEach((location, index) => {
                const locationDiv = document.createElement('div');
                locationDiv.className = 'simple-location-input';
                locationDiv.id = `place${location.position}`;
                
                // Create letter boxes for the location name with word spacing
                const words = location.name.split(' ');
                const inputBoxesHTML = words.map(word => {
                    const boxes = word.split('').map(() => 
                        '<input type="text" class="letter-box" value="" maxlength="1">'
                    ).join('');
                    return `<div class="word-group">${boxes}</div>`;
                }).join('');
                
                locationDiv.innerHTML = `
                    <div class="simple-location-label">Location ${location.position}</div>
                    <div class="input-container">
                        ${inputBoxesHTML}
                    </div>
                `;
                
                container.appendChild(locationDiv);
            });
            
            // Add input event listeners
            setupInputHandlers();
        }

        function generateFinalLocationInput() {
            const container = document.getElementById('finalLocationContainer');
            container.innerHTML = '';
            
            if (!currentCase.finalLocationV2) return;
            
            const finalLocation = currentCase.finalLocationV2;
            const locationDiv = document.createElement('div');
            locationDiv.className = 'simple-location-input';
            locationDiv.id = 'finalPlace';
            
            // Create letter boxes for the final location name
            const words = finalLocation.name.split(' ');
            const inputBoxesHTML = words.map(word => {
                const boxes = word.split('').map(() => 
                    '<input type="text" class="letter-box" value="" maxlength="1">'
                ).join('');
                return `<div class="word-group">${boxes}</div>`;
            }).join('');
            
            locationDiv.innerHTML = `
                <div class="input-container">
                    ${inputBoxesHTML}
                </div>
            `;
            
            container.appendChild(locationDiv);
            
            // Add input event listeners for final location
            setupInputHandlers();
        }

        function setupInputHandlers() {
            const inputs = document.querySelectorAll('.letter-box');
            inputs.forEach((input, index) => {
                input.addEventListener('input', function() {
                    if (this.value.length === 1) {
                        this.classList.add('filled');
                        const nextInput = this.nextElementSibling;
                        if (nextInput && nextInput.classList.contains('letter-box') && !nextInput.value) {
                            nextInput.focus();
                        }
                    } else {
                        this.classList.remove('filled');
                    }
                });
                
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Backspace' && !this.value) {
                        const prevInput = this.previousElementSibling;
                        if (prevInput && prevInput.classList.contains('letter-box')) {
                            prevInput.focus();
                        }
                    }
                });
            });
        }

        // displayV2Turn function moved to line 1740 to avoid duplicate

        function addV2TimelineEntry(turn) {
            // Store for rendering
            if (!window.v2TimelineEntries) {
                window.v2TimelineEntries = [];
            }
            
            // Don't add duplicate turns
            if (window.v2TimelineEntries.some(entry => entry.turn === turn.turn)) {
                return;
            }
            
            window.v2TimelineEntries.push(turn);
        }

        function updateV2TimelineView() {
            const container = document.getElementById('timelineContainer');
            if (!currentCase || !window.v2TimelineEntries) return;
            
            let html = '';
            
            // Sort turns by turn number
            const sortedTurns = window.v2TimelineEntries.sort((a, b) => a.turn - b.turn);
            
            sortedTurns.forEach(turn => {
                const isActive = turn.turn <= currentTurn;
                const phaseText = 'Crime Scene Investigation';
                
                html += `<div class="timeline-turn ${isActive ? 'active' : 'inactive'}">`;
                html += `<div class="timeline-turn-header">`;
                html += `<span class="turn-number">TURN ${turn.turn}</span>`;
                html += `<span class="turn-title">${phaseText}</span>`;
                html += `</div>`;
                
                // Turn narrative
                if (turn.narrative) {
                    html += `<div class="timeline-entry text-entry">`;
                    html += `<div class="entry-content">${turn.narrative}</div>`;
                    html += `</div>`;
                }
                
                // Special handling for Turn 1 - show connection web first
                if (turn.turn === 1) {
                    const distances = turn.clues.filter(c => c.type === 'distance');
                    const timeDiffs = turn.clues.filter(c => c.type === 'time_difference');
                    
                    if (distances.length === 3 && timeDiffs.length === 3) {
                        html += `<div class="timeline-entry clue-entry distance-diagram-entry">`;
                        html += `<div class="clue-header">üï∏Ô∏è Connection Analysis</div>`;
                        html += `<div class="distance-diagram-container">`;
                        html += createConnectionWeb(distances, timeDiffs);
                        html += `</div></div>`;
                    }
                }
                
                // Process clues (non-distance/time clues for Turn 1, all clues for other turns)
                turn.clues.forEach(clue => {
                    html += renderV2Clue(clue, turn.turn);
                });
                
                html += `</div>`;
            });
            
            container.innerHTML = html;
        }

        function renderV2Clue(clue, turnNumber) {
            let html = `<div class="timeline-entry clue-entry clue-${clue.type}">`;
            
            switch (clue.type) {
                case 'theme':
                    html += `<div class="clue-header">üéØ Theme</div>`;
                    html += `<div class="clue-content">${clue.content || currentCase.theme || 'Theme revealed'}</div>`;
                    if (clue.description) {
                        html += `<div class="clue-description">${clue.description}</div>`;
                    }
                    break;
                
                case 'distance':
                case 'time_difference':
                    // Skip individual distance and time clues in Turn 1 (they're in connection web)
                    // But show them in other turns if they exist
                    if (turnNumber === 1) {
                        return '';
                    }
                    
                    const header = clue.type === 'distance' ? 'üìè Distance' : 'üïê Timezone';
                    html += `<div class="clue-header">${header}</div>`;
                    if (clue.description) {
                        html += `<div class="clue-content">${clue.description}</div>`;
                    }
                    if (clue.content) {
                        html += `<div class="clue-shorthand">${clue.content}</div>`;
                    }
                    break;
                
                case 'image':
                    html += `<div class="clue-header">üì∏ Evidence Photo</div>`;
                    
                    // Find the location that has an image for this turn
                    const location = currentCase.locationsV2.find(loc => 
                        loc.hasImage && loc.imageTurn === turnNumber
                    );
                    
                    if (location && location.imageUrl) {
                        html += `
                            <img src="${location.imageUrl}" 
                                 class="evidence-thumbnail" 
                                 onclick="openEvidenceModal('${location.imageUrl}', 'Turn ${turnNumber} Evidence')"
                                 title="Click to view full size">
                        `;
                    }
                    
                    if (clue.description) {
                        html += `<div class="clue-description">${clue.description}</div>`;
                    }
                    break;
                
                case 'breakthrough':
                    html += `<div class="clue-header">üí° Breakthrough</div>`;
                    html += `<div class="clue-content breakthrough-content">${clue.content}</div>`;
                    break;
                
                default:
                    html += `<div class="clue-header">üìù Intel</div>`;
                    html += `<div class="clue-content">${clue.content}</div>`;
            }
            
            html += `</div>`;
            return html;
        }


        function updateV2LocationsView() {
            const container = document.getElementById('locationsDossiers');
            if (!currentCase || !currentCase.locationsV2) return;
            
            let html = '';
            
            // Get distance and time data from Turn 1 for calculating relative distances/times
            let distanceData = {};
            let timeData = {};
            if (window.v2TimelineEntries && window.v2TimelineEntries.some(t => t.turn === 1)) {
                const turn1 = window.v2TimelineEntries.find(t => t.turn === 1);
                if (turn1) {
                    const distances = turn1.clues.filter(c => c.type === 'distance');
                    const timeDiffs = turn1.clues.filter(c => c.type === 'time_difference');
                    
                    distances.forEach(d => {
                        const data = typeof d.data === 'string' ? JSON.parse(d.data) : d.data;
                        if (data && data.between && data.kilometers) {
                            const key = `${data.between[0]}-${data.between[1]}`;
                            distanceData[key] = {kilometers: data.kilometers, miles: data.miles || Math.round(data.kilometers * 0.621371)};
                        }
                    });
                    
                    timeDiffs.forEach(t => {
                        const data = typeof t.data === 'string' ? JSON.parse(t.data) : t.data;
                        if (data && data.between && typeof data.hours !== 'undefined') {
                            const key = `${data.between[0]}-${data.between[1]}`;
                            timeData[key] = data.hours;
                        }
                    });
                }
            }
            
            // Helper functions to get distance and time between locations
            const getDistance = (from, to) => {
                const key1 = `${from}-${to}`;
                const key2 = `${to}-${from}`;
                return distanceData[key1] || distanceData[key2] || null;
            };
            
            const getTimeDiff = (from, to) => {
                const key1 = `${from}-${to}`;
                const key2 = `${to}-${from}`;
                const timeDiff = timeData[key1] !== undefined ? timeData[key1] : timeData[key2];
                return timeDiff !== undefined ? timeDiff : null;
            };
            
            currentCase.locationsV2.forEach((location, index) => {
                html += `<div class="location-dossier">`;
                html += `<div class="dossier-header">`;
                html += `<h4 class="dossier-title">Location ${location.position}</h4>`;
                html += `</div>`;
                
                // Evidence photos
                if (location.hasImage && location.imageUrl && location.imageTurn <= currentTurn) {
                    html += `<div class="dossier-section">`;
                    html += `<h5 class="dossier-section-title">Evidence Photo</h5>`;
                    html += `<div class="dossier-images">`;
                    html += `
                        <div class="dossier-image" onclick="openEvidenceModal('${location.imageUrl}', 'Location ${location.position} Evidence')">
                            <img src="${location.imageUrl}" alt="Evidence">
                            <div class="dossier-image-label">Turn ${location.imageTurn}</div>
                        </div>
                    `;
                    html += `</div></div>`;
                }
                
                // Location-specific clues (clues that apply to this location)
                if (window.v2TimelineEntries) {
                    const locationSpecificClues = [];
                    window.v2TimelineEntries.forEach(turn => {
                        if (turn.turn <= currentTurn) {
                            turn.clues.forEach(clue => {
                                // Skip distance and time clues (handled in geographic section)
                                if (clue.type !== 'distance' && clue.type !== 'time_difference') {
                                    // Check if this clue applies to this location
                                    let appliesHere = false;
                                    
                                    if (clue.locationPositions) {
                                        try {
                                            const positions = JSON.parse(clue.locationPositions);
                                            appliesHere = positions.includes(location.position);
                                        } catch (e) {
                                            // Fallback for malformed data
                                            appliesHere = false;
                                        }
                                    } else {
                                        // For image clues, check if they belong to this location
                                        if (clue.type === 'image') {
                                            appliesHere = location.hasImage && location.imageTurn === turn.turn;
                                        } else {
                                            // For clues without location data, treat as general (don't show in location-specific sections)
                                            appliesHere = false;
                                        }
                                    }
                                    
                                    if (appliesHere) {
                                        locationSpecificClues.push({...clue, turnNumber: turn.turn});
                                    }
                                }
                            });
                        }
                    });
                    
                    if (locationSpecificClues.length > 0) {
                        html += `<div class="dossier-section">`;
                        html += `<h5 class="dossier-section-title">Location-Specific Clues</h5>`;
                        
                        // Group clues by turn for better organization
                        const cluesByTurn = {};
                        locationSpecificClues.forEach(clue => {
                            if (!cluesByTurn[clue.turnNumber]) {
                                cluesByTurn[clue.turnNumber] = [];
                            }
                            cluesByTurn[clue.turnNumber].push(clue);
                        });
                        
                        // Display clues grouped by turn
                        Object.keys(cluesByTurn).sort((a, b) => parseInt(a) - parseInt(b)).forEach(turnNum => {
                            cluesByTurn[turnNum].forEach(clue => {
                                html += `<div class="dossier-clue-item">`;
                                html += `<div class="clue-turn-badge">Turn ${clue.turnNumber}</div>`;
                                html += renderLocationClue(clue, clue.turnNumber);
                                html += `</div>`;
                            });
                        });
                        
                        html += `</div>`;
                    }
                }
                
                // Geographic info (distances and time differences to other locations)
                if (currentTurn >= 1 && Object.keys(distanceData).length > 0) {
                    html += `<div class="dossier-section">`;
                    html += `<h5 class="dossier-section-title">Geographic Data</h5>`;
                    
                    // Distances and time differences to other locations
                    const otherLocations = currentCase.locationsV2.filter(loc => loc.position !== location.position);
                    otherLocations.forEach(otherLoc => {
                        const distance = getDistance(location.position, otherLoc.position);
                        const timeDiff = getTimeDiff(location.position, otherLoc.position);
                        
                        if (distance) {
                            html += `<div class="dossier-info">`;
                            html += `<span class="info-label">Distance to Place ${otherLoc.position}:</span> `;
                            html += `${distance.kilometers.toLocaleString()} km / ${distance.miles.toLocaleString()} miles`;
                            html += `</div>`;
                        }
                        
                        if (timeDiff !== null) {
                            html += `<div class="dossier-info">`;
                            html += `<span class="info-label">Time difference with Place ${otherLoc.position}:</span> `;
                            const sign = timeDiff > 0 ? '+' : '';
                            html += `${sign}${timeDiff}h`;
                            html += `</div>`;
                        }
                    });
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            });
            
            container.innerHTML = html;
        }

        function submitEvidence() {
            // Handle different game states
            if (gameState === 'investigating_crimes') {
                // Check crime scene answers
                checkCrimeSceneAnswers();
                
                // Check if all correct
                const allCrimeLocationsCorrect = crimeSceneAnswers.location1 && crimeSceneAnswers.location2 && crimeSceneAnswers.location3;
                
                if (allCrimeLocationsCorrect) {
                    // Calculate bonus for early completion
                    if (currentTurn < 5) {
                        const bonusPoints = (5 - currentTurn) * 50;
                        gameScore += bonusPoints;
                    }
                    
                    // Unlock final location phase
                    unlockFinalLocationPhase();
                    
                    // Show remaining turns if not at turn 5
                    if (currentTurn < 5) {
                        revealRemainingCrimeTurns();
                    }
                    
                    // Add final location turns
                    addFinalLocationTurns();
                } else {
                    // Progress to next turn or end if turn 5
                    if (currentTurn < 5) {
                        setTimeout(() => {
                            currentTurn++;
                            displayV2Turn(currentTurn);
                            updateV2TurnDisplay();
                            updateActionButton();
                        }, 1000);
                    } else {
                        // Turn 5 reached without solving crime locations - suspect escapes
                        setTimeout(() => {
                            endGameV2('escaped_unsolved');
                        }, 1000);
                    }
                }
            } else if (gameState === 'final_investigation') {
                // Check final location answer
                checkFinalLocationAnswer();
                
                if (finalLocationAnswer) {
                    // Calculate bonus for turn 6
                    if (currentTurn === 6) {
                        gameScore += 100; // Bonus for solving in turn 6
                    }
                    
                    setTimeout(() => {
                        endGameV2('captured');
                    }, 1000);
                } else {
                    // Progress final location turns or end if turn 7
                    if (currentTurn < 7) {
                        setTimeout(() => {
                            currentTurn++;
                            displayV2Turn(currentTurn);
                            updateV2TurnDisplay();
                            updateActionButton();
                        }, 1000);
                    } else {
                        // Turn 7 reached without solving final location - suspect escapes
                        setTimeout(() => {
                            endGameV2('escaped_final');
                        }, 1000);
                    }
                }
            }
        }

        function checkCrimeSceneAnswers() {
            currentCase.locationsV2.forEach((location, index) => {
                if (!crimeSceneAnswers[`location${location.position}`]) { // Only check if not already correct
                    const inputContainers = document.querySelectorAll(`#place${location.position} .input-container`);
                    const wordGroups = inputContainers[0].querySelectorAll('.word-group');
                    
                    // Reconstruct the entered answer
                    let enteredAnswer = '';
                    wordGroups.forEach((group, groupIndex) => {
                        if (groupIndex > 0) enteredAnswer += ' '; // Add space between words
                        const letterBoxes = group.querySelectorAll('.letter-box');
                        letterBoxes.forEach(box => {
                            enteredAnswer += box.value.toUpperCase();
                        });
                    });
                    
                    // Check if answer is correct
                    if (enteredAnswer.trim() === location.name.toUpperCase()) {
                        // Mark as correct
                        crimeSceneAnswers[`location${location.position}`] = true;
                        correctLocations[location.position - 1] = true; // Update global tracking
                        
                        // Calculate score based on turn (more points for earlier guesses)
                        const turnScore = (6 - currentTurn) * 100;
                        gameScore += turnScore;
                        
                        // Lock the inputs and style them as correct
                        const letterBoxes = inputContainers[0].querySelectorAll('.letter-box');
                        letterBoxes.forEach(box => {
                            box.classList.add('correct');
                            box.disabled = true;
                        });
                    } else {
                        // Clear incorrect inputs
                        const letterBoxes = inputContainers[0].querySelectorAll('.letter-box');
                        letterBoxes.forEach(box => {
                            box.value = '';
                            box.classList.remove('filled');
                        });
                    }
                }
            });
        }

        function checkFinalLocationAnswer() {
            if (!currentCase.finalLocationV2) return;
            
            const inputContainers = document.querySelectorAll('#finalPlace .input-container');
            const wordGroups = inputContainers[0].querySelectorAll('.word-group');
            
            // Reconstruct the entered answer
            let enteredAnswer = '';
            wordGroups.forEach((group, groupIndex) => {
                if (groupIndex > 0) enteredAnswer += ' '; // Add space between words
                const letterBoxes = group.querySelectorAll('.letter-box');
                letterBoxes.forEach(box => {
                    enteredAnswer += box.value.toUpperCase();
                });
            });
            
            // Check if answer is correct
            if (enteredAnswer.trim() === currentCase.finalLocationV2.name.toUpperCase()) {
                // Mark as correct
                finalLocationAnswer = true;
                correctLocations[3] = true; // Update global tracking (4th location)
                
                // Calculate score based on turn (more points for turn 6)
                const turnScore = (8 - currentTurn) * 100;
                gameScore += turnScore;
                
                // Lock the inputs and style them as correct
                const letterBoxes = inputContainers[0].querySelectorAll('.letter-box');
                letterBoxes.forEach(box => {
                    box.classList.add('correct');
                    box.disabled = true;
                });
            } else {
                // Clear incorrect inputs
                const letterBoxes = inputContainers[0].querySelectorAll('.letter-box');
                letterBoxes.forEach(box => {
                    box.value = '';
                    box.classList.remove('filled');
                });
            }
        }

        function checkLocationMatch(answer, correct) {
            const normalizedAnswer = answer.toLowerCase().trim();
            const normalizedCorrect = correct.toLowerCase().trim();
            return normalizedAnswer === normalizedCorrect || 
                   normalizedAnswer.includes(normalizedCorrect) ||
                   normalizedCorrect.includes(normalizedAnswer);
        }

        function showCrimeSceneFeedback(results) {
            ['location1', 'location2', 'location3'].forEach(key => {
                const feedbackElement = document.getElementById(`feedback${key.slice(-1)}`);
                if (results[key]) {
                    feedbackElement.textContent = '‚úì Correct';
                    feedbackElement.className = 'input-feedback correct';
                    document.getElementById(key).disabled = true;
                    document.getElementById(key).classList.add('correct');
                } else {
                    feedbackElement.textContent = '‚úó Incorrect';
                    feedbackElement.className = 'input-feedback incorrect';
                }
            });
        }

        function unlockFinalLocationPhase() {
            gameState = 'crimes_solved';
            
            // Update objective description based on final location objective
            const objectiveMap = {
                'WHERE_STASHED': 'where did the villain stash the stolen goods?',
                'NEXT_TARGET': 'where will the villain strike next?',
                'VILLAIN_HIDEOUT': 'where is the villain hiding?',
                'EVIDENCE_SOURCE': 'where did the key evidence originate?',
                'VILLAIN_HOMETOWN': 'where is the villain originally from?',
                'ACCOMPLICE_LOCATION': 'where is the villain\'s partner located?',
                'ESCAPE_ROUTE': 'where does the villain plan to flee?',
                'FAMILY_TIES': 'where are the villain\'s family connections?',
                'TREASURE_DESTINATION': 'where does the villain plan to sell the goods?',
                'VILLAIN_INSPIRATION': 'what location inspired the crime spree?',
                'FINAL_HEIST': 'what is the villain\'s ultimate target?',
                'CRIME_ORIGIN': 'where did the villain learn their skills?',
                'RETIREMENT_PLAN': 'where does the villain plan to retire?'
            };
            
            const description = objectiveMap[currentCase.finalLocationObjective] || 'where is the final location?';
            document.getElementById('finalObjectiveDescription').textContent = `Based on the evidence, ${description} Check Investigation Journal for new clues.`;
            
            // Generate final location letter boxes
            generateFinalLocationInput();
            
            // Show final location phase
            document.getElementById('finalLocationPhase').classList.remove('hidden');
            
            // Show Final Location option in dropdown
            document.getElementById('finalOption').style.display = 'block';
        }

        function updateActionButton() {
            const actionButton = document.getElementById('actionButton');
            
            if (gameState === 'investigating_crimes') {
                // Crime scene phase
                actionButton.textContent = `Turn ${currentTurn} Check`;
                actionButton.className = `action-button turn-${currentTurn}`;
            } else if (gameState === 'final_investigation') {
                // Final location phase
                actionButton.textContent = `Turn ${currentTurn} Check`;
                actionButton.className = `action-button turn-${currentTurn}`;
            } else if (gameState === 'case_complete') {
                actionButton.style.display = 'none';
            }
        }

        function revealRemainingCrimeTurns() {
            // Show all remaining turns 1-5 instantly
            for (let turn = currentTurn + 1; turn <= 5; turn++) {
                displayV2Turn(turn);
            }
            currentTurn = 5;
            updateV2TurnDisplay();
        }

        function addFinalLocationTurns() {
            gameState = 'final_investigation';
            
            // Show final location section
            document.getElementById('finalLocationSection').classList.remove('hidden');
            
            // Start with turn 6
            setTimeout(() => {
                currentTurn = 6;
                displayV2Turn(6);
                updateV2TurnDisplay();
                updateActionButton();
            }, 1000);
        }

        function checkFinalLocation() {
            const finalAnswer = document.getElementById('finalLocationInput').value.trim();
            const correctAnswer = currentCase.finalLocationV2.name;
            
            const isCorrect = checkLocationMatch(finalAnswer, correctAnswer);
            
            if (isCorrect) {
                finalLocationAnswer = true;
                showCaseComplete();
                stopTimer();
            } else {
                showFinalLocationFeedback(false);
            }
        }

        function showFinalLocationFeedback(isCorrect) {
            const feedbackElement = document.getElementById('finalFeedback');
            if (isCorrect) {
                feedbackElement.textContent = '‚úì Correct';
                feedbackElement.className = 'input-feedback correct';
                document.getElementById('finalLocationInput').disabled = true;
                document.getElementById('finalLocationInput').classList.add('correct');
            } else {
                feedbackElement.textContent = '‚úó Incorrect';
                feedbackElement.className = 'input-feedback incorrect';
            }
        }

        function endGameV2(result) {
            // Stop timer
            stopTimer();
            
            const allCrimeLocationsCorrect = correctLocations[0] && correctLocations[1] && correctLocations[2];
            const finalLocationCorrect = correctLocations[3];
            const allLocationsCorrect = allCrimeLocationsCorrect && finalLocationCorrect;
            
            const timeTaken = gameTimer;
            const minutes = Math.floor(timeTaken / 60);
            const seconds = timeTaken % 60;
            
            let modalContent = '';
            let headerText = '';
            
            if (result === 'captured') {
                // All locations correct - show CAPTURED
                headerText = 'SUSPECT CAPTURED!';
                modalContent = `
                    <div class="villain-capture">
                        <img src="${currentCase.villainImageUrl}" alt="${currentCase.villainName}" class="villain-capture-image">
                        <div class="captured-stamp">CAPTURED</div>
                    </div>
                    <h2 class="villain-capture-title">${currentCase.villainName}</h2>
                    <p class="villain-capture-subtitle">"${currentCase.villainTitle}"</p>
                `;
            } else {
                // Suspect escaped
                headerText = 'SUSPECT ESCAPED';
                let escapeReason = '';
                if (result === 'escaped_unsolved') {
                    escapeReason = 'Failed to identify all crime scene locations in time.';
                } else if (result === 'escaped_final') {
                    escapeReason = 'Failed to locate the suspect\'s final hideout.';
                }
                
                modalContent = `
                    <div class="villain-capture">
                        <img src="${currentCase.villainImageUrl}" alt="${currentCase.villainName}" class="villain-capture-image">
                    </div>
                    <h2 class="villain-escape-title">SUSPECT ESCAPED</h2>
                    <p class="villain-escape-subtitle">${escapeReason}</p>
                    <p class="try-again-text">The suspect remains at large. Try again to capture them!</p>
                `;
            }
            
            // Add statistics
            modalContent += `
                <div class="game-stats">
                    <div class="stat-row">
                        <span class="stat-label">Crime Locations Found:</span>
                        <span class="stat-value">${correctLocations.slice(0,3).filter(loc => loc).length} / 3</span>
                    </div>`;
            
            if (allCrimeLocationsCorrect) {
                modalContent += `
                    <div class="stat-row">
                        <span class="stat-label">Final Location Found:</span>
                        <span class="stat-value">${finalLocationCorrect ? 'Yes' : 'No'}</span>
                    </div>`;
            }
            
            modalContent += `
                    <div class="stat-row">
                        <span class="stat-label">Score:</span>
                        <span class="stat-value">${gameScore} points</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Time:</span>
                        <span class="stat-value">${minutes}:${seconds.toString().padStart(2, '0')}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Turns Used:</span>
                        <span class="stat-value">${currentTurn} / 7</span>
                    </div>
                </div>
            `;
            
            if (result === 'captured') {
                modalContent += `<p class="interesting-fact">${currentCase.finalInterestingFact}</p>`;
            }
            
            // Update modal
            document.getElementById('endGameHeader').textContent = headerText;
            document.getElementById('endGameContent').innerHTML = modalContent;
            document.getElementById('endGameModal').classList.add('show');
            
            // Save game result
            saveGameResultV2(result === 'captured', timeTaken, gameScore, currentTurn, finalLocationCorrect);
        }

        async function saveGameResultV2(success, timeTaken, score, turnsUsed, finalLocationCorrect) {
            console.log('üíæ SAVING GAME RESULT:', {
                success,
                score,
                turnsUsed,
                finalLocationCorrect,
                currentUser: currentUser ? currentUser.username : 'NOT SIGNED IN'
            });
            
            const gameResult = {
                caseId: currentCase.id,
                success: success,
                timeTaken: timeTaken,
                score: score,
                turnsUsed: turnsUsed,
                date: new Date().toISOString(),
                correctLocations: correctLocations
            };
            
            // Always save to localStorage as backup with size limits
            try {
                const MAX_RESULTS = 100; // Limit to prevent memory bloat
                
                let savedResults = JSON.parse(localStorage.getItem('gameResultsV2') || '[]');
                savedResults.push(gameResult);
                
                // Keep only the most recent results
                if (savedResults.length > MAX_RESULTS) {
                    savedResults = savedResults.slice(-MAX_RESULTS);
                }
                
                localStorage.setItem('gameResultsV2', JSON.stringify(savedResults));
                
                // Save to user-specific localStorage
                if (currentUser) {
                    const userKey = `userResults_${currentUser.id}`;
                    let userResults = JSON.parse(localStorage.getItem(userKey) || '[]');
                    
                    // Add additional fields for compatibility with gallery
                    const userResult = {
                        ...gameResult,
                        captured: success, // For compatibility with V1 format
                        gameId: currentCase.id, // Alternative field name
                        pointsEarned: score,
                        userId: currentUser.id,
                        userName: currentUser.username || currentUser.name
                    };
                    
                    userResults.push(userResult);
                    
                    // Keep only the most recent user results
                    if (userResults.length > MAX_RESULTS) {
                        userResults = userResults.slice(-MAX_RESULTS);
                    }
                    
                    localStorage.setItem(userKey, JSON.stringify(userResults));
                }
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
            }
            
            // Save to database if user is logged in
            if (currentUser && currentCase) {
                console.log('üöÄ SUBMITTING TO DATABASE:', {
                    playerId: currentUser.id,
                    playerEmail: currentUser.email,
                    playerUsername: currentUser.username || currentUser.name,
                    solvedLocations: correctLocations.filter(Boolean).length >= 3,
                    solvedFinal: finalLocationCorrect || false,
                    pointsEarned: score || 0,
                    turnsUsed: turnsUsed || 0,
                    gameId: currentCase.id
                });
                
                try {
                    const response = await fetch(`/api/v2/games/${currentCase.id}/submit-result`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            playerId: currentUser.id,
                            playerEmail: currentUser.email,
                            playerUsername: currentUser.username || currentUser.name,
                            solvedLocations: correctLocations.filter(Boolean).length >= 3,
                            solvedFinal: finalLocationCorrect || false,
                            pointsEarned: score || 0,
                            turnsUsed: turnsUsed || 0,
                            timeTaken: timeTaken || 0
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úÖ Game result saved to database:', result.message);
                        
                        if (result.newRecord) {
                            console.log('üéâ New personal record achieved!');
                        }
                    } else {
                        const errorData = await response.json();
                        console.error('‚ùå Failed to save to database:', errorData.error);
                    }
                } catch (error) {
                    console.error('‚ùå Network error saving to database:', error);
                    
                    // Save to session storage for retry later
                    try {
                        sessionStorage.setItem('pendingGameResultV2', JSON.stringify({
                            gameId: currentCase.id,
                            playerId: currentUser.id,
                            playerEmail: currentUser.email,
                            playerUsername: currentUser.username || currentUser.name,
                            solvedLocations: correctLocations.filter(Boolean).length >= 3,
                            solvedFinal: finalLocationCorrect || false,
                            pointsEarned: score || 0,
                            turnsUsed: turnsUsed || 0,
                            timeTaken: timeTaken || 0,
                            timestamp: new Date().toISOString()
                        }));
                        console.log('üíæ Result saved to session storage for retry');
                    } catch (sessionError) {
                        console.error('Failed to save to session storage:', sessionError);
                    }
                }
            } else {
                if (!currentUser) {
                    console.warn('‚ö†Ô∏è  USER NOT SIGNED IN - Score will NOT appear on leaderboard!');
                    console.warn('‚ö†Ô∏è  Sign in via the user menu to save scores to database');
                } else if (!currentCase) {
                    console.error('‚ùå No current case data available');
                }
                console.log('‚ÑπÔ∏è  Result saved locally only (not submitted to leaderboard)');
            }
        }


        function updateHeaderForUser() {
            // Update the header to show signed-in state
            setTimeout(() => {
                if (currentUser) {
                    // Update user menu button text
                    const userMenuText = document.getElementById('userMenuText');
                    if (userMenuText) {
                        userMenuText.textContent = currentUser.username || currentUser.name || 'User';
                    }
                    
                    // Show signed-in menu, hide signed-out menu
                    const signedOutMenu = document.getElementById('signedOutMenu');
                    const signedInMenu = document.getElementById('signedInMenu');
                    const menuUserName = document.getElementById('menuUserName');
                    
                    if (signedOutMenu) signedOutMenu.classList.add('hidden');
                    if (signedInMenu) signedInMenu.classList.remove('hidden');
                    if (menuUserName) menuUserName.textContent = currentUser.username || currentUser.name || 'Detective';
                    
                    }
            }, 200);
        }

        function closeEndGameModal() {
            document.getElementById('endGameModal').classList.remove('show');
        }

        function playAgain() {
            window.location.href = 'index.html';
        }

        function showCaseComplete() {
            gameState = 'case_complete';
            
            // Hide other phases
            document.getElementById('crimeScenePhase').classList.add('hidden');
            document.getElementById('finalLocationPhase').classList.add('hidden');
            
            // Show completion
            const completionElement = document.getElementById('caseComplete');
            completionElement.classList.remove('hidden');
            
            // Set completion message
            document.getElementById('completionMessage').textContent = currentCase.gameCompletionMessage;
            document.getElementById('finalFact').textContent = currentCase.finalInterestingFact;
            
            // Show time
            const minutes = Math.floor(gameTimer / 60);
            const seconds = gameTimer % 60;
            document.getElementById('finalTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateV2TurnDisplay() {
            const dots = document.querySelectorAll('.turn-dot');
            const progressFill = document.getElementById('progressFill');
            
            // Update progress bar (0-100% for turns 1-7)
            const progress = Math.min((currentTurn / 7) * 100, 100);
            progressFill.style.width = progress + '%';
            
            // Update turn dots
            dots.forEach((dot, index) => {
                const turnNumber = index + 1;
                dot.classList.remove('active', 'completed');
                
                if (turnNumber < currentTurn) {
                    dot.classList.add('completed');
                } else if (turnNumber === currentTurn) {
                    dot.classList.add('active');
                }
            });
        }

        function createConnectionWeb(distances, timeDiffs) {
            try {
                // Extract distance data from stored clues
                const distanceMap = {};
                distances.forEach(d => {
                    const data = typeof d.data === 'string' ? JSON.parse(d.data) : d.data;
                    if (data && data.between && data.kilometers) {
                        const key = `${data.between[0]}-${data.between[1]}`;
                        distanceMap[key] = data.kilometers;
                    }
                });
                
                // Extract time difference data from stored clues
                const timeMap = {};
                timeDiffs.forEach(t => {
                    const data = typeof t.data === 'string' ? JSON.parse(t.data) : t.data;
                    if (data && data.between && typeof data.hours !== 'undefined') {
                        const key = `${data.between[0]}-${data.between[1]}`;
                        timeMap[key] = data.hours;
                    }
                });
                
                // Get longitude coordinates for west-to-east ordering
                const locationCoords = {};
                if (window.currentCase && window.currentCase.locationsV2) {
                    window.currentCase.locationsV2.forEach(loc => {
                        locationCoords[loc.position] = loc.longitude;
                    });
                }
                
                // Sort locations by longitude (west to east: negative to positive)
                const sortedLocations = [1, 2, 3].sort((a, b) => {
                    const lonA = locationCoords[a] || 0;
                    const lonB = locationCoords[b] || 0;
                    return lonA - lonB; // Sort west to east
                });
                
                console.log('Location coordinates:', locationCoords);
                console.log('Sorted locations (west to east):', sortedLocations);
                console.log('Distance map:', distanceMap);
                console.log('Time map:', timeMap);
                
                // Check if we have all required data
                if (Object.keys(distanceMap).length !== 3 || Object.keys(timeMap).length !== 3) {
                    console.warn('Missing distance or time data for diagram', {
                        distanceKeys: Object.keys(distanceMap),
                        timeKeys: Object.keys(timeMap)
                    });
                }
                
                // Helper function to get stored distance between places
                const getStoredDistance = (from, to) => {
                    const key1 = `${from}-${to}`;
                    const key2 = `${to}-${from}`;
                    return distanceMap[key1] || distanceMap[key2] || 0;
                };
                
                // Helper function to get stored time difference between places
                const getStoredTimeDiff = (from, to) => {
                    const key1 = `${from}-${to}`;
                    const key2 = `${to}-${from}`;
                    // Return the exact stored value, don't reverse it
                    return timeMap[key1] !== undefined ? timeMap[key1] : (timeMap[key2] !== undefined ? timeMap[key2] : 0);
                };
                
                const westPlace = sortedLocations[0];   // Westernmost
                const middlePlace = sortedLocations[1]; // Middle  
                const eastPlace = sortedLocations[2];   // Easternmost
                
                // Get time differences between adjacent places in west-to-east order
                const timeWestToMiddle = getStoredTimeDiff(westPlace, middlePlace);
                const timeMiddleToEast = getStoredTimeDiff(middlePlace, eastPlace);
                
                // Get all distances
                const distWestMiddle = getStoredDistance(westPlace, middlePlace);
                const distMiddleEast = getStoredDistance(middlePlace, eastPlace);
                const distWestEast = getStoredDistance(westPlace, eastPlace);
            
            // Calculate distance in miles for each pair
            const distWestMiddleMiles = Math.round(distWestMiddle * 0.621371);
            const distMiddleEastMiles = Math.round(distMiddleEast * 0.621371);
            const distWestEastMiles = Math.round(distWestEast * 0.621371);
            
            // Format time differences with +/- symbols
            const formatTimeDiff = (hours) => {
                return hours > 0 ? `+${hours}h` : hours < 0 ? `${hours}h` : '0h';
            };

            return `
                <div class="geographic-flow-display">
                    <h3 style="font-family: 'Courier New', monospace; font-size: 16px; font-weight: 700; color: #1A5B5B; margin: 0 0 20px 0; text-align: center; text-transform: uppercase; border-bottom: 2px solid #1A5B5B; padding-bottom: 8px;">
                        üåç Geographic Layout (West ‚Üí East)
                    </h3>
                    
                    <!-- Places Row with Time Differences (Single Row) -->
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; overflow-x: auto; min-height: 80px;">
                        <!-- Westernmost Place -->
                        <div style="background: #1A5B5B; color: white; padding: 12px 16px; border-radius: 8px; text-align: center; font-family: 'Courier New', monospace; font-weight: 700; min-width: 70px; flex-shrink: 0;">
                            <div style="font-size: 18px;">${westPlace}</div>
                            <div style="font-size: 10px; margin-top: 2px;">PLACE ${westPlace}</div>
                        </div>
                        
                        <!-- Arrow with time difference -->
                        <div style="display: flex; flex-direction: column; align-items: center; margin: 0 6px; flex-shrink: 0;">
                            <div style="font-family: 'Courier New', monospace; font-size: 12px; font-weight: 700; color: #FF4500; margin-bottom: 2px;">
                                ${formatTimeDiff(timeWestToMiddle)}
                            </div>
                            <div style="font-size: 20px; color: #1A5B5B;">‚Üî</div>
                        </div>
                        
                        <!-- Middle Place -->
                        <div style="background: #FF4500; color: white; padding: 12px 16px; border-radius: 8px; text-align: center; font-family: 'Courier New', monospace; font-weight: 700; min-width: 70px; flex-shrink: 0;">
                            <div style="font-size: 18px;">${middlePlace}</div>
                            <div style="font-size: 10px; margin-top: 2px;">PLACE ${middlePlace}</div>
                        </div>
                        
                        <!-- Arrow with time difference -->
                        <div style="display: flex; flex-direction: column; align-items: center; margin: 0 6px; flex-shrink: 0;">
                            <div style="font-family: 'Courier New', monospace; font-size: 12px; font-weight: 700; color: #FF4500; margin-bottom: 2px;">
                                ${formatTimeDiff(timeMiddleToEast)}
                            </div>
                            <div style="font-size: 20px; color: #1A5B5B;">‚Üî</div>
                        </div>
                        
                        <!-- Easternmost Place -->
                        <div style="background: #1A1A1A; color: white; padding: 12px 16px; border-radius: 8px; text-align: center; font-family: 'Courier New', monospace; font-weight: 700; min-width: 70px; flex-shrink: 0;">
                            <div style="font-size: 18px;">${eastPlace}</div>
                            <div style="font-size: 10px; margin-top: 2px;">PLACE ${eastPlace}</div>
                        </div>
                    </div>
                    
                    <!-- Distance Information (New Format) -->
                    <div style="background: rgba(26, 91, 91, 0.1); border: 2px solid #1A5B5B; border-radius: 12px; padding: 16px;">
                        <h4 style="font-family: 'Courier New', monospace; font-size: 14px; font-weight: 700; color: #1A5B5B; margin: 0 0 12px 0; text-align: center; text-transform: uppercase;">
                            üìè Distances Between Places
                        </h4>
                        
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px; font-family: 'Courier New', monospace;">
                            <div style="text-align: center; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #1A5B5B;">
                                <div style="font-weight: 700; color: #1A5B5B; font-size: 14px;">Place ${westPlace} -- Place ${middlePlace}</div>
                                <div style="font-weight: 700; color: #FF4500; font-size: 13px; margin-top: 2px;">${distWestMiddle.toLocaleString()} km / ${distWestMiddleMiles.toLocaleString()} miles</div>
                            </div>
                            
                            <div style="text-align: center; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #FF4500;">
                                <div style="font-weight: 700; color: #1A5B5B; font-size: 14px;">Place ${middlePlace} -- Place ${eastPlace}</div>
                                <div style="font-weight: 700; color: #FF4500; font-size: 13px; margin-top: 2px;">${distMiddleEast.toLocaleString()} km / ${distMiddleEastMiles.toLocaleString()} miles</div>
                            </div>
                            
                            <div style="text-align: center; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #1A1A1A;">
                                <div style="font-weight: 700; color: #1A5B5B; font-size: 14px;">Place ${westPlace} -- Place ${eastPlace}</div>
                                <div style="font-weight: 700; color: #FF4500; font-size: 13px; margin-top: 2px;">${distWestEast.toLocaleString()} km / ${distWestEastMiles.toLocaleString()} miles</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            } catch (error) {
                console.error('Error creating connection web:', error);
                return '';
            }
        }
        
        function startElapsedTimer() {
            if (timerInterval) clearInterval(timerInterval);
            
            timerInterval = setInterval(() => {
                gameTimer++;
                updateTimerDisplay();
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameTimer / 60);
            const seconds = gameTimer % 60;
            const timerValue = document.getElementById('timerValue');
            if (timerValue) {
                timerValue.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerValue.style.color = 'var(--primary-orange)';
                timerValue.style.borderColor = 'var(--primary-orange)';
            }
        }

        function stopTimer() {
            if (timerInterval) clearInterval(timerInterval);
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            if (tabName === 'caseDetails') {
                document.getElementById('caseDetailsTab').classList.add('active');
                document.getElementById('caseDetailsPanel').classList.add('active');
            } else if (tabName === 'investigation') {
                document.getElementById('investigationTab').classList.add('active');
                document.getElementById('investigationPanel').classList.add('active');
                // Initialize with appropriate view based on what's available
                const dropdown = document.getElementById('viewDropdown');
                const distancesOption = document.getElementById('distancesOption');
                
                if (distancesOption.style.display !== 'none') {
                    // If distances are available, show distances view
                    dropdown.value = 'distances';
                    switchView();
                } else {
                    // Otherwise default to first city
                    dropdown.value = 'location1';
                    switchView();
                }
            } else if (tabName === 'answers') {
                document.getElementById('answersTab').classList.add('active');
                document.getElementById('answersPanel').classList.add('active');
            }
            
            activeTab = tabName;
        }

        function switchView() {
            const dropdown = document.getElementById('viewDropdown');
            const selectedValue = dropdown.value;
            
            // Hide all views
            document.querySelectorAll('.evidence-view').forEach(view => {
                view.classList.add('hidden');
            });
            
            // Show selected view and update content
            const viewId = selectedValue + 'View';
            document.getElementById(viewId).classList.remove('hidden');
            
            switch (selectedValue) {
                case 'distances':
                    updateDistancesView();
                    break;
                case 'location1':
                    updateLocationEvidence(1);
                    break;
                case 'location2':
                    updateLocationEvidence(2);
                    break;
                case 'location3':
                    updateLocationEvidence(3);
                    break;
                case 'final':
                    updateFinalEvidence();
                    break;
            }
        }

        function updateDistancesView() {
            const container = document.getElementById('distancesContent');
            if (!currentCase || !window.v2TimelineEntries) {
                container.innerHTML = '<div class="no-evidence">No investigation data available yet.</div>';
                return;
            }
            
            let html = '';
            
            // Only show Turn 4 content for Distances view
            const turn4 = window.v2TimelineEntries.find(t => t.turn === 4);
            
            if (!turn4) {
                container.innerHTML = '<div class="no-evidence">No distance information available yet.</div>';
                return;
            }
            
            const distances = turn4.clues.filter(c => c.type === 'distance');
            const timeDiffs = turn4.clues.filter(c => c.type === 'time_difference');
            
            if (distances.length === 3 && timeDiffs.length === 3) {
                html += `<div class="location-header">
                    <h4>Geographic Analysis</h4>
                    <p class="location-subtitle">Distances and time differences between cities</p>
                </div>`;
                
                html += `<div class="timeline-entry clue-entry distance-diagram-entry">`;
                html += `<div class="clue-header">üï∏Ô∏è Connection Analysis</div>`;
                html += `<div class="distance-diagram-container">`;
                html += createConnectionWeb(distances, timeDiffs);
                html += `</div></div>`;
            } else {
                html = '<div class="no-evidence">Distance and timezone data not yet available.</div>';
            }
            
            container.innerHTML = html;
        }

        function updateLocationEvidence(locationPosition) {
            const container = document.getElementById(`location${locationPosition}Evidence`);
            if (!currentCase || !window.v2TimelineEntries) {
                container.innerHTML = '<div class="no-evidence">No evidence available for this city yet.</div>';
                return;
            }
            
            let html = '';
            const locationClues = [];
            
            // Gather ALL clues for this location (including general ones)
            window.v2TimelineEntries.forEach(turn => {
                if (turn.turn <= currentTurn) {
                    turn.clues.forEach(clue => {
                        let appliesHere = false;
                        
                        // Check if clue applies to this location
                        if (clue.locationPositions) {
                            try {
                                const positions = JSON.parse(clue.locationPositions);
                                appliesHere = positions.includes(locationPosition);
                            } catch (e) {
                                // If parsing fails, check if it's a general clue
                                appliesHere = false;
                            }
                        } else if (clue.type === 'image') {
                            // For image clues, check if they belong to this location
                            const location = currentCase.locationsV2.find(loc => 
                                loc.position === locationPosition && loc.hasImage && loc.imageTurn === turn.turn
                            );
                            appliesHere = !!location;
                        } else {
                            // For clues without location positions, check if they're general/theme clues
                            // that should be shown everywhere (like distance, theme, etc.)
                            if (['theme', 'distance', 'time_difference'].includes(clue.type)) {
                                appliesHere = false; // These are handled in Distances view
                            } else {
                                // For other clues without location data, show them as they might be relevant
                                appliesHere = true;
                            }
                        }
                        
                        if (appliesHere) {
                            locationClues.push({
                                ...clue, 
                                turnNumber: turn.turn,
                                narrative: turn.narrative
                            });
                        }
                    });
                }
            });
            
            if (locationClues.length > 0) {
                html += `<div class="location-header">
                    <h4>City ${locationPosition} Evidence</h4>
                    <p class="location-subtitle">Evidence and clues related to this city</p>
                </div>`;
                
                locationClues.forEach(clue => {
                    html += renderLocationClue(clue);
                });
            } else {
                html = `<div class="no-evidence">
                    <h4>City ${locationPosition}</h4>
                    <p>No specific evidence for this city has been discovered yet.</p>
                    <p class="hint">Continue investigating to uncover city-specific clues.</p>
                </div>`;
            }
            
            container.innerHTML = html;
        }

        function updateFinalEvidence() {
            const container = document.getElementById('finalEvidence');
            if (!currentCase || !window.v2TimelineEntries) {
                container.innerHTML = '<div class="no-evidence">Final location evidence will appear after solving the crime scenes.</div>';
                return;
            }
            
            let html = '';
            const finalClues = [];
            
            // Find final location clues (turns 6-7)
            window.v2TimelineEntries.forEach(turn => {
                if (turn.turn <= currentTurn && turn.isFinalLocation) {
                    turn.clues.forEach(clue => {
                        finalClues.push({
                            ...clue,
                            turnNumber: turn.turn,
                            narrative: turn.narrative
                        });
                    });
                }
            });
            
            if (finalClues.length > 0) {
                html += `<div class="location-header">
                    <h4>Final Location Investigation</h4>
                    <p class="location-subtitle">Critical evidence for determining the final location</p>
                </div>`;
                
                finalClues.forEach(clue => {
                    html += renderLocationClue(clue);
                });
            } else {
                html = `<div class="no-evidence">
                    <h4>Final Location</h4>
                    <p>Complete the crime scene investigation to unlock final location evidence.</p>
                </div>`;
            }
            
            container.innerHTML = html;
        }

        function renderLocationClue(clue) {
            let html = `<div class="evidence-card">`;
            
            // Turn badge
            html += `<div class="evidence-turn">Turn ${clue.turnNumber}</div>`;
            
            // Clue type and content
            switch (clue.type) {
                case 'theme':
                    html += `<div class="evidence-type">üéØ Theme</div>`;
                    html += `<div class="evidence-content">${clue.content || currentCase.theme || 'Theme revealed'}</div>`;
                    break;
                
                case 'image':
                    html += `<div class="evidence-type">üì∏ Evidence Photo</div>`;
                    
                    // Find the location image for this turn
                    const location = currentCase.locationsV2.find(loc => 
                        loc.hasImage && loc.imageTurn === clue.turnNumber
                    );
                    
                    if (location && location.imageUrl) {
                        html += `
                            <div class="evidence-image-container">
                                <img src="${location.imageUrl}" 
                                     class="evidence-image" 
                                     onclick="openEvidenceModal('${location.imageUrl}', 'Turn ${clue.turnNumber} Evidence')"
                                     title="Click to view full size">
                            </div>
                        `;
                    }
                    break;
                
                case 'breakthrough':
                    html += `<div class="evidence-type">üí° Breakthrough</div>`;
                    html += `<div class="evidence-content breakthrough">${clue.content}</div>`;
                    break;
                
                case 'pattern_recognition':
                    html += `<div class="evidence-type">üß© Pattern Recognition</div>`;
                    
                    // Parse the content to separate label from emojis
                    const content = clue.content || '';
                    const colonIndex = content.indexOf(':');
                    if (colonIndex !== -1) {
                        const label = content.substring(0, colonIndex + 1);
                        const emojiPattern = content.substring(colonIndex + 1).trim();
                        html += `<div class="evidence-content pattern-recognition">
                            <div class="pattern-label">${label}</div>
                            <div class="emoji-pattern">${emojiPattern}</div>
                        </div>`;
                    } else {
                        // Fallback if no colon found
                        html += `<div class="evidence-content pattern-recognition">
                            <div class="emoji-pattern">${content}</div>
                        </div>`;
                    }
                    break;
                
                default:
                    html += `<div class="evidence-type">üìù Intelligence</div>`;
                    html += `<div class="evidence-content">${clue.content}</div>`;
            }
            
            // Description if available (but NOT for pattern_recognition clues)
            if (clue.description && clue.type !== 'pattern_recognition') {
                html += `<div class="evidence-description">${clue.description}</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        function openEvidenceModal(imageUrl, title) {
            document.getElementById('modalHeader').textContent = title;
            document.getElementById('modalImage').src = imageUrl;
            document.getElementById('imageModal').classList.add('show');
        }

        function closeImageModal() {
            document.getElementById('imageModal').classList.remove('show');
        }


        function showError(message) {
            document.getElementById('loadingContainer').classList.add('hidden');
            document.getElementById('errorContainer').classList.remove('hidden');
            document.getElementById('errorContainer').classList.add('show-flex');
            document.querySelector('#errorContainer p').textContent = message;
        }

        // Reuse existing modal functions from detective.html
        function showVillainModal() {
            // Implementation from original detective.html
        }

        function displayV2Turn(turnNumber) {
            // Find the turn data
            const turn = currentCase.gameplayTurns.find(t => t.turn === turnNumber);
            if (!turn) {
                console.warn(`Turn ${turnNumber} not found`);
                return;
            }
            
            // Add turn to timeline
            addV2TimelineEntry(turn);
            
            // Show distances option when Turn 4 is reached
            if (turnNumber === 4) {
                console.log('Turn 4 reached, showing distances option');
                document.getElementById('distancesOption').style.display = 'block';
            }
            
            // Update Investigation Journal views based on current dropdown selection
            const dropdown = document.getElementById('viewDropdown');
            if (dropdown) {
                if (dropdown.value === 'distances') {
                    updateDistancesView();
                } else if (dropdown.value.startsWith('location')) {
                    const locationNum = parseInt(dropdown.value.replace('location', ''));
                    updateLocationEvidence(locationNum);
                } else if (dropdown.value === 'final') {
                    updateFinalEvidence();
                }
            }
        }

        function updateV2TurnDisplay() {
            // Update turn indicators with new styling
            for (let i = 1; i <= 7; i++) {
                const turnDot = document.getElementById(`turn${i}`);
                if (turnDot) {
                    // Remove all state classes
                    turnDot.classList.remove('active', 'past', 'current');
                    
                    if (i < currentTurn) {
                        // Past turns - green
                        turnDot.classList.add('past');
                    } else if (i === currentTurn) {
                        // Current turn - orange with glow
                        turnDot.classList.add('current');
                    }
                    // Future turns remain with default styling
                }
            }
            
            // Update progress bar
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                const progressPercent = (currentTurn / 7) * 100;
                progressFill.style.width = `${progressPercent}%`;
            }
            
            // Show final location section if we're past turn 5
            if (currentTurn > 5) {
                const finalSection = document.getElementById('finalLocationSection');
                if (finalSection) {
                    finalSection.classList.remove('hidden');
                }
            }
        }

        function addV2Turn(turn) {
            // Use the existing addV2TimelineEntry function
            addV2TimelineEntry(turn);
        }

        // View switching functions

        function updateV2LocationsView() {
            const container = document.getElementById('locationsContainer');
            if (!currentCase || !window.v2TimelineEntries) return;
            
            // Implement locations view for V2 games
            let html = '<div class="locations-grid">';
            
            // Add content for locations view
            currentCase.locationsV2.forEach((location, index) => {
                html += `<div class="location-card">
                    <h4>Location ${index + 1}</h4>
                    <p>${location.name}, ${location.country}</p>
                </div>`;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('imageModal');
            if (event.target === modal) {
                closeImageModal();
            }
        }

        // Google Authentication
        let currentUser = null;
        
        // Initialize Google Sign-In after page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Check if user is already signed in
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                updateUserUI();
                updateHeaderForUser();
            } else {
            }
        });
        
        // Initialize Google Sign-In when script loads
        async function initializeGoogleSignIn() {
            if (typeof google !== 'undefined' && google.accounts) {
                try {
                    // Fetch Google Client ID from server
                    const configResponse = await fetch('/api/config');
                    const config = await configResponse.json();
                    
                    if (config.googleClientId) {
                        google.accounts.id.initialize({
                            client_id: config.googleClientId,
                            callback: handleCredentialResponse,
                            auto_select: false,
                            cancel_on_tap_outside: true
                        });
                    } else {
                        console.error('Google Client ID not configured on server');
                    }
                } catch (error) {
                    console.error('Failed to load Google Client ID:', error);
                }
            } else {
                // Retry after a short delay if Google script hasn't loaded yet
                setTimeout(initializeGoogleSignIn, 100);
            }
        }
        
        // Start initialization
        initializeGoogleSignIn();
        
        function signIn() {
            if (typeof google === 'undefined' || !google.accounts) {
                console.error('Google Sign-In not loaded');
                alert('Google Sign-In is not available. Please try refreshing the page.');
                return;
            }
            
            // Skip One Tap and go directly to popup to avoid FedCM issues
            renderSignInButton();
        }
        
        function renderSignInButton() {
            // Create a temporary container for the sign-in button
            const tempContainer = document.createElement('div');
            tempContainer.id = 'tempSignInContainer';
            tempContainer.className = 'sign-in-modal-container';
            
            tempContainer.innerHTML = `
                <h3 class="sign-in-modal-title">Sign In to Worldwide Chase</h3>
                <div id="googleSignInButton"></div>
                <button onclick="closeSignInModal()" class="sign-in-cancel-button">Cancel</button>
            `;
            
            document.body.appendChild(tempContainer);
            
            // Render Google Sign-In button
            google.accounts.id.renderButton(
                document.getElementById('googleSignInButton'),
                {
                    theme: 'outline',
                    size: 'large',
                    text: 'signin_with',
                    shape: 'rectangular'
                }
            );
        }
        
        function closeSignInModal() {
            const modal = document.getElementById('tempSignInContainer');
            if (modal) {
                modal.remove();
            }
        }
        
        function handleCredentialResponse(response) {
            // Close sign-in modal if open
            closeSignInModal();
            
            // Decode JWT token
            const responsePayload = decodeJwtResponse(response.credential);
            
            const googleUser = {
                id: responsePayload.sub,
                fullName: responsePayload.name,
                email: responsePayload.email,
                picture: responsePayload.picture,
                firstName: responsePayload.given_name || responsePayload.name.split(' ')[0]
            };
            
            // Check if this is a new user
            const existingUser = localStorage.getItem(`user_${googleUser.id}`);
            
            if (!existingUser) {
                // New user - show signup modal
                showSignupModal(googleUser);
            } else {
                // Existing user - load their profile
                currentUser = JSON.parse(existingUser);
                // Update with latest Google info
                currentUser.fullName = googleUser.fullName;
                currentUser.email = googleUser.email;
                currentUser.picture = googleUser.picture;
                
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                localStorage.setItem(`user_${currentUser.id}`, JSON.stringify(currentUser));
                
                updateUserUI();
                savePendingGameResult();
            }
        }
        
        function showSignupModal(googleUser) {
            const modal = document.createElement('div');
            modal.id = 'signupModal';
            modal.className = 'signup-modal';
            
            modal.innerHTML = `
                <div class="signup-modal-content">
                    <h2 class="signup-modal-title">Welcome to Worldwide Chase!</h2>
                    <p class="signup-modal-text">Choose a username for your detective profile:</p>
                    
                    <div class="signup-input-container">
                        <label class="signup-input-label">Username:</label>
                        <input type="text" id="usernameInput" value="${googleUser.firstName}" class="signup-input" maxlength="20" placeholder="Enter username">
                        <small class="signup-input-hint">This will be displayed on leaderboards and your profile</small>
                    </div>
                    
                    <div class="signup-button-container">
                        <button onclick="completeSignup()" class="signup-button">Start Playing</button>
                        <button onclick="cancelSignup()" class="signup-cancel-button">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Store google user data temporarily
            window.tempGoogleUser = googleUser;
            
            // Focus on username input
            setTimeout(() => {
                const input = document.getElementById('usernameInput');
                input.focus();
                input.select();
                
                // Allow Enter key to complete signup
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        completeSignup();
                    }
                });
            }, 100);
        }
        
        function completeSignup() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            const googleUser = window.tempGoogleUser;
            
            currentUser = {
                id: googleUser.id,
                username: username,
                fullName: googleUser.fullName,
                email: googleUser.email,
                picture: googleUser.picture,
                joinedAt: new Date().toISOString()
            };
            
            // Save user profile
            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            localStorage.setItem(`user_${currentUser.id}`, JSON.stringify(currentUser));
            
            // Close modal
            closeSignupModal();
            
            // Update UI
            updateUserUI();
            
            // Save any pending game results
            savePendingGameResult();
            
            // Clean up temp data
            delete window.tempGoogleUser;
        }
        
        function cancelSignup() {
            closeSignupModal();
            delete window.tempGoogleUser;
        }
        
        function closeSignupModal() {
            const modal = document.getElementById('signupModal');
            if (modal) {
                modal.remove();
            }
        }
        
        function decodeJwtResponse(token) {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        }
        
        function updateUserUI() {
            const userMenuText = document.getElementById('userMenuText');
            const signedOutMenu = document.getElementById('signedOutMenu');
            const signedInMenu = document.getElementById('signedInMenu');
            const menuUserName = document.getElementById('menuUserName');
            
            // Safety check - if header elements aren't loaded yet, return early
            if (!userMenuText || !signedOutMenu || !signedInMenu) {
                return;
            }
            
            if (currentUser) {
                // Update button text to show username
                userMenuText.textContent = currentUser.username || currentUser.name || currentUser.fullName;
                
                // Show signed-in menu, hide signed-out menu
                signedOutMenu.classList.add('hidden');
                signedInMenu.classList.remove('hidden');
                signedInMenu.classList.add('show');
                
                // Update user name in menu
                if (menuUserName) {
                    menuUserName.textContent = `Detective ${currentUser.username || currentUser.name || currentUser.fullName}`;
                }
            } else {
                // Show "Sign In" text
                userMenuText.textContent = 'Sign In';
                
                // Show signed-out menu, hide signed-in menu
                signedOutMenu.classList.remove('hidden');
                signedOutMenu.classList.add('show');
                signedInMenu.classList.add('hidden');
            }
        }
        
        async function savePendingGameResult() {
            // Check if there's a pending result to save
            const pendingResult = sessionStorage.getItem('pendingGameResult');
            if (pendingResult && currentUser) {
                const result = JSON.parse(pendingResult);
                result.userId = currentUser.id;
                result.userName = currentUser.name;
                
                try {
                    // TODO: Send to server API when implemented
                    // await fetch('/api/results', {
                    //     method: 'POST',
                    //     headers: { 'Content-Type': 'application/json' },
                    //     body: JSON.stringify(result)
                    // });
                    
                    // For now, save to localStorage with size limits
                    const MAX_RESULTS = 100; // Prevent memory bloat
                    const userResults = JSON.parse(localStorage.getItem(`userResults_${currentUser.id}`) || '[]');
                    userResults.push(result);
                    
                    // Keep only the most recent results
                    if (userResults.length > MAX_RESULTS) {
                        userResults.splice(0, userResults.length - MAX_RESULTS);
                    }
                    
                    localStorage.setItem(`userResults_${currentUser.id}`, JSON.stringify(userResults));
                    
                    sessionStorage.removeItem('pendingGameResult');
                } catch (error) {
                    console.error('Error saving game result:', error);
                }
            }
        }

        // User Menu Functions
        function toggleUserMenu() {
            const button = document.getElementById('userMenuButton');
            const dropdown = document.getElementById('userMenuDropdown');
            const isOpen = !dropdown.classList.contains('hidden');
            
            if (isOpen) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            } else {
                dropdown.classList.remove('hidden');
                dropdown.classList.add('show');
                button.classList.add('open');
            }
        }

        // Close user menu when clicking outside
        document.addEventListener('click', function(event) {
            const userMenuContainer = document.getElementById('userMenuContainer');
            if (userMenuContainer && !userMenuContainer.contains(event.target)) {
                const dropdown = document.getElementById('userMenuDropdown');
                const button = document.getElementById('userMenuButton');
                if (dropdown && !dropdown.classList.contains('hidden')) {
                    dropdown.classList.add('hidden');
                    dropdown.classList.remove('show');
                    button.classList.remove('open');
                }
            }
        });

        // Help Modal Functions
        function showHelpModal() {
            document.getElementById('helpModal').classList.add('show');
            // Close user menu if open
            const dropdown = document.getElementById('userMenuDropdown');
            const button = document.getElementById('userMenuButton');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            }
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('show');
        }

        // Close help modal when clicking outside
        const helpModal = document.getElementById('helpModal');
        if (helpModal) {
            helpModal.addEventListener('click', function(event) {
                if (event.target === this) {
                    closeHelpModal();
                }
            });
        }

        // Close modals with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const helpModal = document.getElementById('helpModal');
                const profileModal = document.getElementById('profileModal');
                if (helpModal.classList.contains('show')) {
                    closeHelpModal();
                }
                if (profileModal.classList.contains('show')) {
                    closeProfileModal();
                }
            }
        });

        // Profile Modal Functions
        function showProfileModal() {
            updateProfileDisplay();
            document.getElementById('profileModal').classList.add('show');
            // Close user menu if open
            const dropdown = document.getElementById('userMenuDropdown');
            const button = document.getElementById('userMenuButton');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            }
        }

        function closeProfileModal() {
            document.getElementById('profileModal').classList.remove('show');
        }

        // Close profile modal when clicking outside (with safety check)
        setTimeout(() => {
            const profileModal = document.getElementById('profileModal');
            if (profileModal) {
                profileModal.addEventListener('click', function(event) {
                    if (event.target === this) {
                        closeProfileModal();
                    }
                });
            }
        }, 100);

        function updateProfileDisplay() {
            const editButton = document.getElementById('editUsernameBtn');
            
            if (currentUser) {
                // Show username instead of full name
                document.getElementById('profileUserName').textContent = currentUser.username || currentUser.name || currentUser.fullName;
                document.getElementById('profileUserEmail').textContent = currentUser.email || '';
                
                // Show edit button when user is logged in
                editButton.classList.remove('hidden');
                
                // Get user stats
                const userResults = JSON.parse(localStorage.getItem(`userResults_${currentUser.id}`) || '[]');
                const casesPlayed = userResults.length;
                
                document.getElementById('profileCasesPlayed').textContent = `Cases Solved: ${casesPlayed}`;
                
                if (casesPlayed > 0) {
                    const averageScore = Math.round(userResults.reduce((sum, result) => sum + result.score, 0) / casesPlayed);
                    const bestTime = Math.min(...userResults.map(result => result.timeTaken));
                    const bestTimeMinutes = Math.floor(bestTime / 60);
                    const bestTimeSeconds = bestTime % 60;
                    
                    document.getElementById('profileAverageScore').textContent = `Average Score: ${averageScore}`;
                    document.getElementById('profileBestTime').textContent = `Best Time: ${bestTimeMinutes}m ${bestTimeSeconds}s`;
                } else {
                    document.getElementById('profileAverageScore').textContent = 'Average Score: N/A';
                    document.getElementById('profileBestTime').textContent = 'Best Time: N/A';
                }
            } else {
                document.getElementById('profileUserName').textContent = 'Sign in to track your progress';
                document.getElementById('profileUserEmail').textContent = 'N/A';
                document.getElementById('profileCasesPlayed').textContent = 'Cases Solved: 0';
                document.getElementById('profileAverageScore').textContent = 'Average Score: N/A';
                document.getElementById('profileBestTime').textContent = 'Best Time: N/A';
                
                // Hide edit button when not logged in
                editButton.classList.add('hidden');
            }
        }

        // Sign out function
        function signOut() {
            currentUser = null;
            localStorage.removeItem('currentUser');
            updateUserUI();
            // Close user menu
            const dropdown = document.getElementById('userMenuDropdown');
            const button = document.getElementById('userMenuButton');
            if (dropdown) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            }
        }

        // Edit Username Modal Functions
        function showEditUsernameModal() {
            if (!currentUser) return;
            
            const modal = document.getElementById('editUsernameModal');
            const input = document.getElementById('usernameEditInput');
            
            // Pre-fill with current username
            input.value = currentUser.username || currentUser.name || currentUser.fullName;
            
            modal.classList.add('show');
            
            // Focus and select the input
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }

        function closeEditUsernameModal() {
            document.getElementById('editUsernameModal').classList.remove('show');
        }

        function saveUsername() {
            const newUsername = document.getElementById('usernameEditInput').value.trim();
            
            if (!newUsername) {
                alert('Please enter a username');
                return;
            }
            
            if (newUsername.length < 2) {
                alert('Username must be at least 2 characters long');
                return;
            }
            
            if (newUsername.length > 20) {
                alert('Username must be 20 characters or less');
                return;
            }
            
            // Update current user
            currentUser.username = newUsername;
            
            // Save to localStorage
            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            localStorage.setItem(`user_${currentUser.id}`, JSON.stringify(currentUser));
            
            // Update UI
            updateUserUI();
            updateProfileDisplay();
            
            // Close modal
            closeEditUsernameModal();
        }

        // Close edit username modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('editUsernameModal');
            if (event.target === modal) {
                closeEditUsernameModal();
            }
        });

        // Allow Enter key to save username
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                const modal = document.getElementById('editUsernameModal');
                if (modal.classList.contains('show')) {
                    saveUsername();
                }
            }
        });

        // Villain Modal Functions
        function showVillainModal() {
            if (!gameData) return;
            
            const modal = document.getElementById('villainModal');
            const villainImage = document.getElementById('villainModalImage');
            const villainName = document.getElementById('villainModalName');
            const villainTitle = document.getElementById('villainModalTitle');
            
            // Set villain information
            villainImage.src = gameData.villainImageUrl || '/game/wwc-logo.png';
            villainName.textContent = gameData.villainName || 'Unknown Suspect';
            villainTitle.textContent = gameData.villainTitle || 'Criminal Mastermind';
            
            modal.classList.add('show');
        }

        function closeVillainModal() {
            document.getElementById('villainModal').classList.remove('show');
        }

        // Close villain modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('villainModal');
            if (event.target === modal) {
                closeVillainModal();
            }
        });

        // Add Escape key handler for villain modal
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const villainModal = document.getElementById('villainModal');
                if (villainModal && villainModal.classList.contains('show')) {
                    closeVillainModal();
                }
            }
        });

        // Comprehensive cleanup system for memory leak prevention
        let eventListeners = [];
        
        // Store references to event listeners for cleanup
        function addEventListenerWithCleanup(element, event, handler, options = false) {
            element.addEventListener(event, handler, options);
            eventListeners.push({ element, event, handler, options });
        }
        
        // Cleanup function to remove all event listeners
        function cleanupEventListeners() {
            eventListeners.forEach(({ element, event, handler, options }) => {
                try {
                    element.removeEventListener(event, handler, options);
                } catch (e) {
                    console.warn('Failed to remove event listener:', e);
                }
            });
            eventListeners = [];
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            // Clear timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Clear event listeners
            cleanupEventListeners();
            
            // Clear global arrays
            if (window.v2TimelineEntries) {
                window.v2TimelineEntries = [];
            }
            
            console.log('üßπ Detective game cleanup completed');
        });
        
        // Alternative cleanup for navigation
        window.addEventListener('pagehide', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            cleanupEventListeners();
        });
    </script>

    <!-- Help Modal -->
    <div id="helpModal" class="help-modal">
        <div class="help-modal-content">
            <button class="help-close" onclick="closeHelpModal()">&times;</button>
            <div class="help-modal-header">How to Play</div>
            <div class="help-content">
                <div class="help-section">
                    <h3>üîç Your Mission</h3>
                    <p>Track a criminal across the globe using detective skills and geographic clues. This enhanced case format requires identifying <strong>3 crime scene locations + 1 final hideout location</strong> where the suspect was captured.</p>
                </div>

                <div class="help-section">
                    <h3>üé≤ Investigation Process</h3>
                    <p><strong>Turns 1-5:</strong> Identify 3 crime scene locations</p>
                    <p><strong>Turns 6-7:</strong> Deduce the final hideout to capture the suspect</p>
                    <p><strong>Available Clues:</strong> Pattern recognition puzzles, evidence photos, geographic distances, timezone differences, thematic connections, and breakthrough discoveries. Clues vary by turn and difficulty.</p>
                </div>

                <div class="help-section">
                    <h3>üïµÔ∏è Detective Tools & Tips</h3>
                    <ul>
                        <li><strong>Investigation Journal:</strong> Timeline & Locations views</li>
                        <li><strong>Check Answers:</strong> Submit guesses and track progress</li>
                        <li><strong>Evidence Photos:</strong> Click to examine full-size</li>
                        <li><strong>Timer:</strong> 5 minutes for maximum score</li>
                        <li><strong>Pattern Puzzles:</strong> Solve emoji sequences for location hints</li>
                        <li><strong>Geographic Clues:</strong> Look for specific features</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>üìä Scoring & Leaderboard</h3>
                    <p><strong>Weighted Scoring:</strong> Easy (1x), Medium (1.25x), Hard (1.75x) multipliers reward challenge level.</p>
                    <p><strong>Performance Bonuses:</strong> +75 points for solving first 3 locations in ‚â§5 turns, +100 points for 6th turn final location.</p>
                    <p><strong>Leaderboard:</strong> Compete across difficulty levels - Overall Champions, Easy Champions, Medium Masters, and Hard Heroes. Access via user menu when signed in.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profileModal" class="profile-modal">
        <div class="profile-modal-content">
            <button class="profile-close" onclick="closeProfileModal()">&times;</button>
            <div class="profile-modal-header">Detective Profile</div>
            <div class="profile-content">
                <div class="help-section">
                    <h3>üë§ Account Details</h3>
                    <div class="profile-field">
                        <span><strong>Username:</strong> <span id="profileUserName">Sign in to track your progress</span></span>
                        <button id="editUsernameBtn" class="edit-button hidden" onclick="showEditUsernameModal()">Edit</button>
                    </div>
                    <div class="profile-field">
                        <span><strong>Email:</strong> <span id="profileUserEmail">N/A</span></span>
                    </div>
                </div>

                <div class="help-section">
                    <h3>üìä Detective Stats</h3>
                    <p id="profileCasesPlayed">Cases Solved: 0</p>
                    <p id="profileAverageScore">Average Score: N/A</p>
                    <p id="profileBestTime">Best Time: N/A</p>
                </div>

                <div class="help-section">
                    <h3>üéñÔ∏è Achievements</h3>
                    <p>Coming soon - Track your detective accomplishments!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Username Modal -->
    <div id="editUsernameModal" class="edit-username-modal">
        <div class="edit-username-content">
            <div class="edit-username-header">Edit Username</div>
            <input type="text" id="usernameEditInput" class="username-input" placeholder="Enter new username" maxlength="20">
            <div class="edit-username-buttons">
                <button class="save-username-btn" onclick="saveUsername()">Save</button>
                <button class="cancel-username-btn" onclick="closeEditUsernameModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Villain Image Modal -->
    <div id="villainModal" class="villain-modal">
        <div class="villain-modal-content">
            <button class="villain-modal-close" onclick="closeVillainModal()">&times;</button>
            <div class="villain-modal-header">Suspect Profile</div>
            <img id="villainModalImage" class="villain-modal-image" src="" alt="Villain Portrait">
            <div class="villain-modal-info">
                <div id="villainModalName" class="villain-modal-name"></div>
                <div id="villainModalTitle" class="villain-modal-title"></div>
            </div>
        </div>
    </div>

    <!-- End Game Modal -->
    <div id="endGameModal" class="image-modal">
        <div class="modal-content end-game-modal-content">
            <div class="modal-header" id="endGameHeader">CASE CLOSED</div>
            <div id="endGameContent" class="end-game-content">
                <!-- Content will be populated dynamically -->
            </div>
            <div class="end-game-actions">
                <button class="action-button end-game-button" onclick="playAgain()">
                    Start New Case
                </button>
            </div>
        </div>
    </div>

    <!-- Detective Header Partial -->
    <script src="detective-header.js"></script>

</body>
</html>