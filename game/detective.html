<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Worldwide Chase - Investigation File</title>
    <link rel="icon" type="image/x-icon" href="/game/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="game-container">
        <!-- Loading State -->
        <div class="loading-container" id="loadingContainer">
            <div class="loading-spinner"></div>
            <h3>Loading Case File...</h3>
            <p>Gathering evidence and witness reports</p>
        </div>

        <!-- Error State -->
        <div class="error-container hidden" id="errorContainer">
            <h2>Case Not Found</h2>
            <p>The requested case file could not be located in our database.</p>
            <button class="back-button" onclick="window.location.href = 'index.html'">
                ‚Üê Back to Chase Gallery
            </button>
        </div>

        <!-- Main Game Interface (initially hidden) -->
        <div id="gameInterface" class="hidden">
            <!-- Detective Header Container (injected by detective-header.js) -->
            <div id="detective-header-container"></div>

            <!-- Turn Indicator (modified for V2) -->
            <div class="turn-indicator-container">
                <div class="turn-indicator v2">
                    <div class="turn-progress-line">
                        <div class="turn-progress-fill" id="progressFill"></div>
                    </div>
                    <div class="turn-section crime-scenes">
                        <div class="turn-dot active turn-1" id="turn1">1</div>
                        <div class="turn-dot no-image" id="turn2">2</div>
                        <div class="turn-dot" id="turn3">3</div>
                        <div class="turn-dot no-image" id="turn4">4</div>
                        <div class="turn-dot" id="turn5">5</div>
                    </div>
                    <div class="turn-section final-location hidden" id="finalLocationSection">
                        <div class="turn-dot" id="turn6">6</div>
                        <div class="turn-dot" id="turn7">7</div>
                    </div>
                </div>
            </div>

            <!-- Detective File Tabs -->
            <div class="detective-tabs">
                <div class="tabs-left">
                    <button class="tab-button active" id="caseDetailsTab" onclick="switchTab('caseDetails')">
                        Case Details
                    </button>
                    <button class="tab-button" id="investigationTab" onclick="switchTab('investigation')">
                        Investigation Journal
                    </button>
                    <button class="tab-button" id="answersTab" onclick="switchTab('answers')">
                        Check Answers
                    </button>
                </div>
                <div class="tabs-right">
                    <div class="timer-display">
                        <div class="timer-label">TIME</div>
                        <div class="timer-value" id="timerValue">00:00</div>
                    </div>
                </div>
            </div>

            <!-- Tab Content -->
            <div class="tab-content">
                <!-- Case Details Tab -->
                <div class="tab-panel active" id="caseDetailsPanel">
                    <div class="case-file-layout">
                        <!-- Villain Profile -->
                        <div class="villain-profile">
                            <div class="villain-mugshot">
                                <img id="villainPortrait" alt="" class="villain-portrait clickable" onclick="showVillainModal()">
                                <div class="mugshot-label">SUSPECT</div>
                            </div>
                            <div class="villain-info">
                                <h3 id="villainName"></h3>
                                <p class="villain-title" id="villainTitle"></p>
                            </div>
                        </div>

                        <!-- Case Summary -->
                        <div class="case-section crime-summary">
                            <h4>Case Summary</h4>
                            <p id="crimeSummary"></p>
                        </div>
                        
                        <!-- Investigation Journal Button -->
                        <div class="case-section investigation-button-section">
                            <button class="investigation-journal-button" onclick="switchTab('investigation')">
                                üïµÔ∏è Open Investigation Journal
                            </button>
                            <p class="investigation-button-hint">Review evidence and check your answers</p>
                        </div>
                        
                    </div>
                </div>

                <!-- Investigation Journal Tab -->
                <div class="tab-panel" id="investigationPanel">
                    <div class="clues-board">
                        <div class="clues-header">
                            <h3>Investigation Journal</h3>
                            <p class="clues-subtitle">Evidence and discoveries from your investigation</p>
                            <div class="view-selector">
                                <select class="view-dropdown" id="viewDropdown" onchange="switchView()">
                                    <option value="distances" id="distancesOption" style="display: none;">üìè Distances</option>
                                    <option value="location1">üèôÔ∏è City 1</option>
                                    <option value="location2">üèôÔ∏è City 2</option>
                                    <option value="location3">üèôÔ∏è City 3</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Distances View -->
                        <div class="evidence-view" id="distancesView">
                            <div class="distances-content" id="distancesContent">
                                <!-- Distance and timeline content will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Location Views -->
                        <div class="evidence-view hidden" id="location1View">
                            <div class="location-evidence" id="location1Evidence">
                                <!-- City 1 clues will be populated here -->
                            </div>
                        </div>
                        
                        <div class="evidence-view hidden" id="location2View">
                            <div class="location-evidence" id="location2Evidence">
                                <!-- City 2 clues will be populated here -->
                            </div>
                        </div>
                        
                        <div class="evidence-view hidden" id="location3View">
                            <div class="location-evidence" id="location3Evidence">
                                <!-- City 3 clues will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Check Answers Tab -->
                <div class="tab-panel" id="answersPanel">
                    <div class="game-area">
                        <!-- Description -->
                        <div class="tab-description" id="crimeSceneDescription">
                            <p>Enter city names based on evidence. Check Investigation Journal for clues and photos.</p>
                        </div>
                        
                        <!-- Final Location Instructions (hidden initially) -->
                        <div class="final-location-instructions hidden" id="finalLocationInstructions">
                            <div class="congratulations-header">
                                <h2>üéâ Excellent Detective Work!</h2>
                                <p>You've successfully identified all three crime scene locations. The suspect is cornered!</p>
                            </div>
                            <div class="puzzle-instructions">
                                <h3>üß© Final Challenge</h3>
                                <p>Unscramble the letters below to reveal an educational phrase about the suspect's final location. Use the available letters to fill in the blanks and capture the criminal!</p>
                            </div>
                            
                            <!-- Turn 6 Flag Colors Hint -->
                            <div class="flag-colors-hint" id="flagColorsHint" style="display: none;">
                                <!-- Flag colors will be shown here in Turn 6 -->
                            </div>
                        </div>
                        
                        <!-- Crime Scene Phase -->
                        <div class="answer-phase" id="crimeScenePhase">
                            <div id="crimeLocationInputs">
                                <!-- Crime scene letter box inputs will be generated dynamically -->
                            </div>
                        </div>

                        <!-- Final Location Phase (hidden initially) -->
                        <div class="answer-phase hidden" id="finalLocationPhase">
                            <div class="final-location-container" id="finalLocationContainer">
                                <div class="puzzle-interface">
                                    <!-- Available Letters Section -->
                                    <div class="available-letters-section">
                                        <!-- Remaining Letters -->
                                        <div class="remaining-letters-container">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                                <div class="section-label">Remaining Letters:</div>
                                                <button class="shuffle-letters-btn" onclick="shuffleRemainingLetters()" title="Shuffle letters">üîÑ</button>
                                            </div>
                                            <div class="letters-grid" id="remainingLettersContainer">
                                                <!-- Remaining letter cards will be generated here -->
                                            </div>
                                        </div>
                                        
                                        <!-- Used Letters -->
                                        <div class="used-letters-container">
                                            <div class="section-label">Used Letters:</div>
                                            <div class="letters-grid" id="usedLettersContainer">
                                                <!-- Used letter cards will be shown here -->
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Phrase Input Interface -->
                                    <div class="phrase-input-section">
                                        <p style="text-align: center; font-family: 'Courier New', monospace; color: #495057; margin: 15px 0 10px 0;">Complete the phrase below:</p>
                                        <div class="phrase-input-container" id="phraseInputs">
                                            <!-- Word-grouped input boxes will be generated here -->
                                        </div>
                                        <div class="letter-legend">
                                            <div class="legend-item">
                                                <div class="legend-color used"></div>
                                                <span>Used Letters</span>
                                            </div>
                                            <div class="legend-item">
                                                <div class="legend-color location"></div>
                                                <span>City Name</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Turn 7 Category Hint -->
                                        <div class="category-hint" id="categoryHint" style="display: none;">
                                            <!-- Category hint will be shown here in Turn 7 -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Case Complete (hidden initially) -->
                        <div class="case-complete hidden" id="caseComplete">
                            <h3>üéâ Case Solved!</h3>
                            <div class="completion-message" id="completionMessage"></div>
                            <div class="final-interesting-fact" id="finalFact"></div>
                            <div class="game-stats">
                                <div class="stat-item">
                                    <label>Time Taken:</label>
                                    <span id="finalTime"></span>
                                </div>
                            </div>
                        </div>

                        <!-- Action Button -->
                        <div class="action-button-container">
                            <button class="action-button turn-1" id="actionButton" onclick="submitEvidence()">
                                Turn 1 Check
                            </button>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- Image Modal -->
    <div id="imageModal" class="image-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
            <div class="modal-header" id="modalHeader">Evidence Photo</div>
            <img id="modalImage" class="modal-image" src="" alt="Evidence">
        </div>
    </div>

    <script>
        let currentCase = null;
        let gameData = null;
        let currentTurn = 1;
        let activeTab = 'caseDetails';
        let gameStartTime = null; // Track when game started for time bonus
        let gameTimer = 0;
        let timerInterval = null;
        let cluesViewMode = 'timeline';
        let gameState = 'investigating_crimes'; // investigating_crimes, crimes_solved, final_investigation, case_complete

        // V2 specific variables
        let crimeSceneAnswers = { location1: false, location2: false, location3: false };
        let finalLocationAnswer = false;
        let gameScore = 0;
        let correctLocations = [false, false, false, false]; // Track all 4 locations

        // Load case data on page load
        document.addEventListener('DOMContentLoaded', async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const caseId = urlParams.get('case') || urlParams.get('caseId');
            
            console.log('URL params:', window.location.search);
            console.log('Case ID found:', caseId);
            
            if (!caseId) {
                showError('No case ID provided');
                return;
            }
            
            await loadV2Case(caseId);
        });

        async function loadV2Case(caseId) {
            try {
                const response = await fetch(`/api/v2/games/${caseId}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch V2 game');
                }
                
                currentCase = await response.json();
                
                if (!currentCase) {
                    showError('V2 Game not found');
                    return;
                }
                
                console.log('Loaded case data:');
                console.log('  Locations:', currentCase.locationsV2.map(loc => ({
                    position: loc.position,
                    name: loc.name,
                    id: loc.id
                })));
                console.log('  Final location:', currentCase.finalLocationV2?.name);
                
                initializeV2Game();
                
            } catch (error) {
                console.error('Error loading V2 case:', error);
                showError('Failed to load V2 case data');
            }
        }

        function initializeV2Game() {
            // Hide loading and error states, show game
            document.getElementById('loadingContainer').classList.add('hidden');
            document.getElementById('loadingContainer').style.display = 'none';
            
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.classList.add('hidden');
            errorContainer.classList.remove('show-flex');
            errorContainer.style.display = 'none';
            
            document.getElementById('gameInterface').classList.remove('hidden');
            document.getElementById('gameInterface').classList.add('show-flex', 'flex-column', 'flex-height');
            
            // Reset diagram flag
            window.turn1DiagramShown = false;
            window.connectionWebShown = false;
            
            // Set gameData for modals
            gameData = currentCase;
            
            // Populate case details
            document.getElementById('villainPortrait').src = currentCase.villainImageUrl || '/game/wwc-logo.png';
            document.getElementById('villainPortrait').alt = currentCase.villainName;
            document.getElementById('villainName').textContent = currentCase.villainName;
            document.getElementById('villainTitle').textContent = currentCase.villainTitle;
            document.getElementById('crimeSummary').textContent = currentCase.crimeSummary;
            
            // Set case title in header
            const caseTitleElement = document.getElementById('caseTitle');
            if (caseTitleElement) {
                caseTitleElement.textContent = currentCase.caseTitle || 'Investigation Case';
            }
            
            // Generate location inputs
            generateV2LocationInputs();
            
            // Initialize game state
            updateV2TurnDisplay();
            
            // Start the timer
            gameStartTime = new Date();
            startElapsedTimer();
            
            // Initialize with Turn 1 clues
            displayV2Turn(1);
        }

        function generateV2LocationInputs() {
            const container = document.getElementById('crimeLocationInputs');
            container.innerHTML = '';
            
            // Create letter box inputs for crime scene locations (using actual location names)
            currentCase.locationsV2.forEach((location, index) => {
                const locationDiv = document.createElement('div');
                locationDiv.className = 'simple-location-input';
                locationDiv.id = `place${location.position}`;
                
                // Create letter boxes for the location name with word spacing
                const words = location.name.split(' ');
                const inputBoxesHTML = words.map(word => {
                    const boxes = word.split('').map(() => 
                        '<input type="text" class="letter-box" value="" maxlength="1">'
                    ).join('');
                    return `<div class="word-group">${boxes}</div>`;
                }).join('');
                
                locationDiv.innerHTML = `
                    <div class="simple-location-label">Location ${location.position}</div>
                    <div class="input-container">
                        ${inputBoxesHTML}
                    </div>
                `;
                
                container.appendChild(locationDiv);
            });
            
            // Add input event listeners
            setupInputHandlers();
        }

        // Enhanced puzzle state management
        let puzzleState = {
            phrase: '',
            letterCounts: {}, // Track count of each letter type
            remainingLetters: [], // Letters still available to use
            usedLetters: [], // Letters that have been used
            hintLetters: [], // Letters that are hints
            locationLetters: [], // Letters that spell the location name
            locationNameLetters: [], // Letters specifically used for location name
            currentAttempt: 1
        };

        function generateFinalLocationInput() {
            if (!currentCase.finalLocationV2) return;
            
            const finalLocation = currentCase.finalLocationV2;
            
            // Initialize puzzle with educational phrase
            puzzleState.phrase = finalLocation.educationalPhrase || finalLocation.name;
            
            // Count letters in the phrase
            initializeLetterCounts();
            
            // Create remaining letters based on letter counts
            generateAvailableLetters();
            
            // Identify location name letters for special coloring
            identifyLocationLetters();
            
            // Create word-grouped input boxes for the phrase
            createPhraseInputs();
            
            // Show initial hints based on difficulty
            showDifficultyBasedHints();
            
            // Display the letter cards
            displayLetterCards();
        }

        function initializeLetterCounts() {
            puzzleState.letterCounts = {};
            puzzleState.remainingLetters = [];
            puzzleState.usedLetters = [];
            puzzleState.hintLetters = [];
            puzzleState.locationNameLetters = [];
            
            // Count each letter in the phrase
            const letters = puzzleState.phrase.toUpperCase().replace(/[^A-Z]/g, '').split('');
            letters.forEach(letter => {
                puzzleState.letterCounts[letter] = (puzzleState.letterCounts[letter] || 0) + 1;
            });
        }

        function generateAvailableLetters() {
            // Generate exactly the letters needed for the phrase
            puzzleState.remainingLetters = [];
            Object.keys(puzzleState.letterCounts).forEach(letter => {
                const count = puzzleState.letterCounts[letter];
                for (let i = 0; i < count; i++) {
                    puzzleState.remainingLetters.push(letter);
                }
            });
            
            // Shuffle the remaining letters
            puzzleState.remainingLetters = shuffleArray([...puzzleState.remainingLetters]);
        }

        function identifyLocationLetters() {
            const locationName = currentCase.finalLocationV2.name.toUpperCase();
            puzzleState.locationLetters = [];
            
            // Find which input boxes correspond to the location name
            const phraseUpper = puzzleState.phrase.toUpperCase();
            const cityIndex = phraseUpper.indexOf(locationName);
            
            if (cityIndex !== -1) {
                // Calculate letter positions for the city name
                const beforeCity = puzzleState.phrase.substring(0, cityIndex);
                const letterStartPos = beforeCity.replace(/[^A-Za-z]/g, '').length;
                
                for (let i = 0; i < locationName.length; i++) {
                    puzzleState.locationLetters.push(letterStartPos + i);
                }
            }
        }


        // Display letter cards in separate containers
        function displayLetterCards() {
            displayRemainingLetters();
            displayUsedLetters();
        }

        function displayRemainingLetters() {
            const container = document.getElementById('remainingLettersContainer');
            container.innerHTML = '';
            
            puzzleState.remainingLetters.forEach((letter, index) => {
                const letterCard = createLetterCard(letter, index, false);
                letterCard.addEventListener('click', () => useLetterInInput(letter, letterCard));
                container.appendChild(letterCard);
            });
        }

        function displayUsedLetters() {
            const container = document.getElementById('usedLettersContainer');
            container.innerHTML = '';
            
            puzzleState.usedLetters.forEach((letter, index) => {
                const letterCard = createLetterCard(letter, index, true);
                container.appendChild(letterCard);
            });
        }

        function createLetterCard(letter, index, isUsed) {
            const letterCard = document.createElement('div');
            letterCard.className = 'letter-card';
            letterCard.textContent = letter;
            letterCard.dataset.letter = letter;
            letterCard.dataset.index = index;
            
            if (isUsed) {
                letterCard.classList.add('used');
                // Don't add location-letter class to used letter tiles
                // All used letters should be yellow in the used letters section
                // Only input boxes should have the blue color for location letters
            }
            
            return letterCard;
        }

        // Create input boxes for phrase (word-grouped layout)
        function createPhraseInputs() {
            const words = puzzleState.phrase.split(' ');
            const container = document.getElementById('phraseInputs');
            container.innerHTML = '';
            let globalLetterIndex = 0;
            
            words.forEach((word, wordIndex) => {
                const wordDiv = document.createElement('div');
                wordDiv.className = 'phrase-word-group';
                
                word.split('').forEach((letter, letterIndex) => {
                    if (letter.match(/[A-Za-z]/)) {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.className = 'phrase-letter-input';
                        input.dataset.wordIndex = wordIndex;
                        input.dataset.letterIndex = letterIndex;
                        input.dataset.globalIndex = globalLetterIndex;
                        input.dataset.expectedLetter = letter.toUpperCase();
                        
                        // Color location name inputs differently
                        if (puzzleState.locationLetters.includes(globalLetterIndex)) {
                            input.classList.add('location-letter');
                        }
                        
                        // Auto-advance and validation
                        input.addEventListener('input', handlePhraseInput);
                        input.addEventListener('keydown', handlePhraseKeydown);
                        input.addEventListener('click', handlePhraseInputClick);
                        
                        wordDiv.appendChild(input);
                        globalLetterIndex++;
                    }
                });
                
                container.appendChild(wordDiv);
            });
        }

        // Handle phrase input and auto-advance
        function handlePhraseInput(event) {
            const input = event.target;
            const value = input.value.toUpperCase();
            
            if (value.length === 1) {
                // Validate that the letter is available in remaining letters
                if (!puzzleState.remainingLetters.includes(value)) {
                    // Invalid letter - clear the input and show feedback
                    input.value = '';
                    input.classList.remove('filled');
                    
                    // Brief red flash to indicate invalid input
                    input.style.borderColor = '#dc3545';
                    setTimeout(() => {
                        input.style.borderColor = '';
                    }, 500);
                    
                    console.log(`Invalid letter "${value}" - not available in remaining letters`);
                    return;
                }
                
                input.classList.add('filled');
                input.value = value;
                
                // Move letter from remaining to used
                moveLetterToUsed(value);
                
                // Move to next input
                const nextInput = getNextPhraseInput(input);
                if (nextInput && !nextInput.value) {
                    nextInput.focus();
                }
            } else {
                input.classList.remove('filled');
            }
        }

        function handlePhraseKeydown(event) {
            if (event.key === 'Backspace' && !event.target.value) {
                const prevInput = getPrevPhraseInput(event.target);
                if (prevInput && !prevInput.readOnly) {
                    // Move letter back from used to remaining
                    const prevValue = prevInput.value;
                    if (prevValue) {
                        moveLetterToRemaining(prevValue);
                    }
                    
                    prevInput.focus();
                    prevInput.value = '';
                    prevInput.classList.remove('filled');
                }
            }
        }

        // Handle clicking on input boxes to remove letters
        function handlePhraseInputClick(event) {
            const input = event.target;
            const currentValue = input.value;
            
            // Only allow removal if the input has a value and is not disabled/readonly
            if (currentValue && !input.disabled && !input.readOnly) {
                // Move letter back from used to remaining
                moveLetterToRemaining(currentValue);
                
                // Clear the input and remove filled styling
                input.value = '';
                input.classList.remove('filled');
                
                // Focus the input for potential new input
                input.focus();
            }
        }

        // Move letter from remaining to used
        function moveLetterToUsed(letter) {
            const index = puzzleState.remainingLetters.indexOf(letter);
            if (index !== -1) {
                puzzleState.remainingLetters.splice(index, 1);
                puzzleState.usedLetters.push(letter);
                displayLetterCards();
            }
        }

        // Move letter from used back to remaining
        function moveLetterToRemaining(letter) {
            const index = puzzleState.usedLetters.indexOf(letter);
            if (index !== -1) {
                puzzleState.usedLetters.splice(index, 1);
                puzzleState.remainingLetters.push(letter);
                displayLetterCards();
            }
        }

        function getNextPhraseInput(currentInput) {
            const inputs = Array.from(document.querySelectorAll('.phrase-letter-input'));
            const currentIndex = inputs.indexOf(currentInput);
            return inputs[currentIndex + 1] || null;
        }

        function getPrevPhraseInput(currentInput) {
            const inputs = Array.from(document.querySelectorAll('.phrase-letter-input'));
            const currentIndex = inputs.indexOf(currentInput);
            return inputs[currentIndex - 1] || null;
        }

        // Use letter from card in input
        function useLetterInInput(letter, letterCard) {
            if (letterCard.classList.contains('used')) return;
            
            // Find first empty input that's not a hint
            const inputs = document.querySelectorAll('.phrase-letter-input:not(.hint-letter)');
            for (let input of inputs) {
                if (!input.value) {
                    input.value = letter;
                    input.classList.add('filled');
                    
                    // Move letter from remaining to used
                    moveLetterToUsed(letter);
                    
                    // Move to next input
                    const nextInput = getNextPhraseInput(input);
                    if (nextInput && !nextInput.value) {
                        nextInput.focus();
                    }
                    break;
                }
            }
        }

        // Show hints based on difficulty level
        function showDifficultyBasedHints() {
            const difficulty = currentCase.difficulty || 'medium';
            const cityName = currentCase.finalLocationV2.name.toUpperCase();
            const inputs = document.querySelectorAll('.phrase-letter-input');
            
            // Always reveal first letter of city name
            const phraseUpper = puzzleState.phrase.toUpperCase();
            const cityIndex = phraseUpper.indexOf(cityName);
            
            if (cityIndex !== -1) {
                const beforeCity = puzzleState.phrase.substring(0, cityIndex);
                const letterPosition = beforeCity.replace(/[^A-Za-z]/g, '').length;
                
                if (inputs[letterPosition]) {
                    const firstLetter = cityName[0];
                    fillHintLetter(inputs[letterPosition], firstLetter);
                }
            }
            
            // Apply difficulty-specific hints
            if (difficulty === 'easy') {
                // Easy: Show all instances of the most common letter
                const mostCommonLetter = findMostCommonLetter();
                if (mostCommonLetter) {
                    inputs.forEach(input => {
                        if (input.dataset.expectedLetter === mostCommonLetter && !input.classList.contains('hint-letter')) {
                            fillHintLetter(input, mostCommonLetter);
                        }
                    });
                }
            } else if (difficulty === 'medium') {
                // Medium: Show 2 more random letters
                showRandomHints(2);
            } else if (difficulty === 'hard') {
                // Hard: Show 1 more random letter
                showRandomHints(1);
            }
        }

        function findMostCommonLetter() {
            let maxCount = 0;
            let mostCommon = '';
            
            Object.keys(puzzleState.letterCounts).forEach(letter => {
                if (puzzleState.letterCounts[letter] > maxCount) {
                    maxCount = puzzleState.letterCounts[letter];
                    mostCommon = letter;
                }
            });
            
            return mostCommon;
        }

        function showRandomHints(count) {
            const nonHintInputs = Array.from(document.querySelectorAll('.phrase-letter-input:not(.hint-letter)'));
            
            for (let i = 0; i < count && nonHintInputs.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * nonHintInputs.length);
                const randomInput = nonHintInputs[randomIndex];
                const correctLetter = randomInput.dataset.expectedLetter;
                
                fillHintLetter(randomInput, correctLetter);
                
                // Remove from available list
                nonHintInputs.splice(randomIndex, 1);
            }
        }

        function fillHintLetter(input, letter) {
            input.value = letter;
            input.readOnly = true;
            input.classList.add('hint-letter');
            
            // Check if this is a location name letter for special coloring
            const inputIndex = Array.from(document.querySelectorAll('.phrase-letter-input')).indexOf(input);
            if (puzzleState.locationLetters.includes(inputIndex)) {
                input.classList.add('location-letter');
                puzzleState.locationNameLetters.push(letter);
            }
            
            // Mark this letter as hint and remove from remaining
            puzzleState.hintLetters.push(letter);
            moveLetterToUsed(letter);
        }


        // Shuffle only the remaining letters
        function shuffleRemainingLetters() {
            puzzleState.remainingLetters = shuffleArray([...puzzleState.remainingLetters]);
            displayLetterCards();
        }

        // Utility function to shuffle array
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function setupInputHandlers() {
            const inputs = document.querySelectorAll('.letter-box');
            inputs.forEach((input, index) => {
                input.addEventListener('input', function() {
                    if (this.value.length === 1) {
                        this.classList.add('filled');
                        const nextInput = this.nextElementSibling;
                        if (nextInput && nextInput.classList.contains('letter-box') && !nextInput.value) {
                            nextInput.focus();
                        }
                    } else {
                        this.classList.remove('filled');
                    }
                });
                
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Backspace' && !this.value) {
                        const prevInput = this.previousElementSibling;
                        if (prevInput && prevInput.classList.contains('letter-box')) {
                            prevInput.focus();
                        }
                    }
                });
            });
        }

        // displayV2Turn function moved to line 1740 to avoid duplicate

        function addV2TimelineEntry(turn) {
            // Store for rendering
            if (!window.v2TimelineEntries) {
                window.v2TimelineEntries = [];
            }
            
            // Don't add duplicate turns
            if (window.v2TimelineEntries.some(entry => entry.turn === turn.turn)) {
                return;
            }
            
            window.v2TimelineEntries.push(turn);
        }

        function updateV2TimelineView() {
            const container = document.getElementById('timelineContainer');
            if (!currentCase || !window.v2TimelineEntries) return;
            
            let html = '';
            
            // Sort turns by turn number
            const sortedTurns = window.v2TimelineEntries.sort((a, b) => a.turn - b.turn);
            
            sortedTurns.forEach(turn => {
                const isActive = turn.turn <= currentTurn;
                const phaseText = 'Crime Scene Investigation';
                
                html += `<div class="timeline-turn ${isActive ? 'active' : 'inactive'}">`;
                html += `<div class="timeline-turn-header">`;
                html += `<span class="turn-number">TURN ${turn.turn}</span>`;
                html += `<span class="turn-title">${phaseText}</span>`;
                html += `</div>`;
                
                // Turn narrative
                if (turn.narrative) {
                    html += `<div class="timeline-entry text-entry">`;
                    html += `<div class="entry-content">${turn.narrative}</div>`;
                    html += `</div>`;
                }
                
                // Special handling for Turn 1 - show connection web first
                if (turn.turn === 1) {
                    const distances = turn.clues.filter(c => c.type === 'distance');
                    const timeDiffs = turn.clues.filter(c => c.type === 'time_difference');
                    
                    if (distances.length === 3 && timeDiffs.length === 3) {
                        html += `<div class="timeline-entry clue-entry distance-diagram-entry">`;
                        html += `<div class="clue-header">üï∏Ô∏è Connection Analysis</div>`;
                        html += `<div class="distance-diagram-container">`;
                        html += createConnectionWeb(distances, timeDiffs);
                        html += `</div></div>`;
                    }
                }
                
                // Process clues (non-distance/time clues for Turn 1, all clues for other turns)
                turn.clues.forEach(clue => {
                    html += renderV2Clue(clue, turn.turn);
                });
                
                html += `</div>`;
            });
            
            container.innerHTML = html;
        }

        function renderV2Clue(clue, turnNumber) {
            let html = `<div class="timeline-entry clue-entry clue-${clue.type}">`;
            
            switch (clue.type) {
                case 'theme':
                    html += `<div class="clue-header">üéØ Theme</div>`;
                    html += `<div class="clue-content">${clue.content || currentCase.theme || 'Theme revealed'}</div>`;
                    if (clue.description) {
                        html += `<div class="clue-description">${clue.description}</div>`;
                    }
                    break;
                
                case 'distance':
                case 'time_difference':
                    // Skip individual distance and time clues in Turn 1 (they're in connection web)
                    // But show them in other turns if they exist
                    if (turnNumber === 1) {
                        return '';
                    }
                    
                    const header = clue.type === 'distance' ? 'üìè Distance' : 'üïê Timezone';
                    html += `<div class="clue-header">${header}</div>`;
                    if (clue.description) {
                        html += `<div class="clue-content">${clue.description}</div>`;
                    }
                    if (clue.content) {
                        html += `<div class="clue-shorthand">${clue.content}</div>`;
                    }
                    break;
                
                case 'image':
                    html += `<div class="clue-header">üì∏ Evidence Photo</div>`;
                    
                    // Find the location that has an image for this turn
                    const location = currentCase.locationsV2.find(loc => 
                        loc.hasImage && loc.imageTurn === turnNumber
                    );
                    
                    if (location && location.imageUrl) {
                        html += `
                            <img src="${location.imageUrl}" 
                                 class="evidence-thumbnail" 
                                 onclick="openEvidenceModal('${location.imageUrl}', 'Turn ${turnNumber} Evidence')"
                                 title="Click to view full size">
                        `;
                    }
                    
                    if (clue.description) {
                        html += `<div class="clue-description">${clue.description}</div>`;
                    }
                    break;
                
                case 'breakthrough':
                    html += `<div class="clue-header">üí° Breakthrough</div>`;
                    html += `<div class="clue-content breakthrough-content">${clue.content}</div>`;
                    break;
                
                default:
                    html += `<div class="clue-header">üìù Intel</div>`;
                    html += `<div class="clue-content">${clue.content}</div>`;
            }
            
            html += `</div>`;
            return html;
        }


        function updateV2LocationsView() {
            const container = document.getElementById('locationsDossiers');
            if (!currentCase || !currentCase.locationsV2) return;
            
            let html = '';
            
            // Get distance and time data from Turn 1 for calculating relative distances/times
            let distanceData = {};
            let timeData = {};
            if (window.v2TimelineEntries && window.v2TimelineEntries.some(t => t.turn === 1)) {
                const turn1 = window.v2TimelineEntries.find(t => t.turn === 1);
                if (turn1) {
                    const distances = turn1.clues.filter(c => c.type === 'distance');
                    const timeDiffs = turn1.clues.filter(c => c.type === 'time_difference');
                    
                    distances.forEach(d => {
                        const data = typeof d.data === 'string' ? JSON.parse(d.data) : d.data;
                        if (data && data.between && data.kilometers) {
                            const key = `${data.between[0]}-${data.between[1]}`;
                            distanceData[key] = {kilometers: data.kilometers, miles: data.miles || Math.round(data.kilometers * 0.621371)};
                        }
                    });
                    
                    timeDiffs.forEach(t => {
                        const data = typeof t.data === 'string' ? JSON.parse(t.data) : t.data;
                        if (data && data.between && typeof data.hours !== 'undefined') {
                            const key = `${data.between[0]}-${data.between[1]}`;
                            timeData[key] = data.hours;
                        }
                    });
                }
            }
            
            // Helper functions to get distance and time between locations
            const getDistance = (from, to) => {
                const key1 = `${from}-${to}`;
                const key2 = `${to}-${from}`;
                return distanceData[key1] || distanceData[key2] || null;
            };
            
            const getTimeDiff = (from, to) => {
                const key1 = `${from}-${to}`;
                const key2 = `${to}-${from}`;
                const timeDiff = timeData[key1] !== undefined ? timeData[key1] : timeData[key2];
                return timeDiff !== undefined ? timeDiff : null;
            };
            
            currentCase.locationsV2.forEach((location, index) => {
                html += `<div class="location-dossier">`;
                html += `<div class="dossier-header">`;
                html += `<h4 class="dossier-title">Location ${location.position}</h4>`;
                html += `</div>`;
                
                // Evidence photos
                if (location.hasImage && location.imageUrl && location.imageTurn <= currentTurn) {
                    html += `<div class="dossier-section">`;
                    html += `<h5 class="dossier-section-title">Evidence Photo</h5>`;
                    html += `<div class="dossier-images">`;
                    html += `
                        <div class="dossier-image" onclick="openEvidenceModal('${location.imageUrl}', 'Location ${location.position} Evidence')">
                            <img src="${location.imageUrl}" alt="Evidence">
                            <div class="dossier-image-label">Turn ${location.imageTurn}</div>
                        </div>
                    `;
                    html += `</div></div>`;
                }
                
                // Location-specific clues (clues that apply to this location)
                if (window.v2TimelineEntries) {
                    const locationSpecificClues = [];
                    window.v2TimelineEntries.forEach(turn => {
                        if (turn.turn <= currentTurn) {
                            turn.clues.forEach(clue => {
                                // Skip distance and time clues (handled in geographic section)
                                if (clue.type !== 'distance' && clue.type !== 'time_difference') {
                                    // Check if this clue applies to this location
                                    let appliesHere = false;
                                    
                                    if (clue.locationPositions) {
                                        try {
                                            const positions = JSON.parse(clue.locationPositions);
                                            appliesHere = positions.includes(location.position);
                                        } catch (e) {
                                            // Fallback for malformed data
                                            appliesHere = false;
                                        }
                                    } else {
                                        // For image clues, check if they belong to this location
                                        if (clue.type === 'image') {
                                            appliesHere = location.hasImage && location.imageTurn === turn.turn;
                                        } else {
                                            // For clues without location data, treat as general (don't show in location-specific sections)
                                            appliesHere = false;
                                        }
                                    }
                                    
                                    if (appliesHere) {
                                        locationSpecificClues.push({...clue, turnNumber: turn.turn});
                                    }
                                }
                            });
                        }
                    });
                    
                    if (locationSpecificClues.length > 0) {
                        html += `<div class="dossier-section">`;
                        html += `<h5 class="dossier-section-title">Location-Specific Clues</h5>`;
                        
                        // Group clues by turn for better organization
                        const cluesByTurn = {};
                        locationSpecificClues.forEach(clue => {
                            if (!cluesByTurn[clue.turnNumber]) {
                                cluesByTurn[clue.turnNumber] = [];
                            }
                            cluesByTurn[clue.turnNumber].push(clue);
                        });
                        
                        // Display clues grouped by turn
                        Object.keys(cluesByTurn).sort((a, b) => parseInt(a) - parseInt(b)).forEach(turnNum => {
                            cluesByTurn[turnNum].forEach(clue => {
                                html += `<div class="dossier-clue-item">`;
                                html += `<div class="clue-turn-badge">Turn ${clue.turnNumber}</div>`;
                                html += renderLocationClue(clue, clue.turnNumber);
                                html += `</div>`;
                            });
                        });
                        
                        html += `</div>`;
                    }
                }
                
                // Geographic info (distances and time differences to other locations)
                if (currentTurn >= 1 && Object.keys(distanceData).length > 0) {
                    html += `<div class="dossier-section">`;
                    html += `<h5 class="dossier-section-title">Geographic Data</h5>`;
                    
                    // Distances and time differences to other locations
                    const otherLocations = currentCase.locationsV2.filter(loc => loc.position !== location.position);
                    otherLocations.forEach(otherLoc => {
                        const distance = getDistance(location.position, otherLoc.position);
                        const timeDiff = getTimeDiff(location.position, otherLoc.position);
                        
                        if (distance) {
                            html += `<div class="dossier-info">`;
                            html += `<span class="info-label">Distance to Place ${otherLoc.position}:</span> `;
                            html += `${distance.kilometers.toLocaleString()} km / ${distance.miles.toLocaleString()} miles`;
                            html += `</div>`;
                        }
                        
                        if (timeDiff !== null) {
                            html += `<div class="dossier-info">`;
                            html += `<span class="info-label">Time difference with Place ${otherLoc.position}:</span> `;
                            const sign = timeDiff > 0 ? '+' : '';
                            html += `${sign}${timeDiff}h`;
                            html += `</div>`;
                        }
                    });
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            });
            
            container.innerHTML = html;
        }

        function submitEvidence() {
            // Handle different game states
            if (gameState === 'investigating_crimes') {
                // Check crime scene answers
                checkCrimeSceneAnswers();
                
                // Check if all correct
                const allCrimeLocationsCorrect = crimeSceneAnswers.location1 && crimeSceneAnswers.location2 && crimeSceneAnswers.location3;
                
                console.log('submitEvidence - Crime scene check results:');
                console.log('  location1:', crimeSceneAnswers.location1);
                console.log('  location2:', crimeSceneAnswers.location2);
                console.log('  location3:', crimeSceneAnswers.location3);
                console.log('  allCrimeLocationsCorrect:', allCrimeLocationsCorrect);
                console.log('  currentTurn:', currentTurn);
                
                if (allCrimeLocationsCorrect) {
                    // Score will be calculated at the end of the game
                    
                    // Unlock final location phase
                    unlockFinalLocationPhase();
                    
                    // Show remaining turns if not at turn 5
                    if (currentTurn < 5) {
                        revealRemainingCrimeTurns();
                    }
                    
                    // Add final location turns
                    addFinalLocationTurns();
                } else {
                    // Progress to next turn or end if turn 5
                    if (currentTurn < 5) {
                        setTimeout(() => {
                            currentTurn++;
                            displayV2Turn(currentTurn);
                            updateV2TurnDisplay();
                            updateActionButton();
                        }, 1000);
                    } else {
                        // Turn 5 reached without solving crime locations - suspect escapes
                        setTimeout(() => {
                            endGameV2('escaped_unsolved');
                        }, 1000);
                    }
                }
            } else if (gameState === 'final_investigation') {
                // Check final location answer
                checkFinalLocationAnswer();
                
                if (finalLocationAnswer) {
                    // Score will be calculated at the end of the game
                    
                    setTimeout(() => {
                        endGameV2('captured');
                    }, 1000);
                } else if (currentTurn === 7) {
                    // Turn 7 and still wrong - now the game ends
                    setTimeout(() => {
                        endGameV2('escaped_final');
                    }, 1000);
                } else if (currentTurn === 6) {
                    // Turn 6 failed - advance to Turn 7 with hints
                    setTimeout(() => {
                        currentTurn = 7;
                        // Don't call displayV2Turn(7) as Turn 7 doesn't exist in database
                        // Just update the turn display and action button
                        updateV2TurnDisplay();
                        updateActionButton();
                        
                        // Flag colors are already shown in Turn 6, no need to show again
                    }, 1000);
                }
            }
        }

        function checkCrimeSceneAnswers() {
            console.log('=== checkCrimeSceneAnswers DEBUG START ===');
            console.log('Current crimeSceneAnswers state:', JSON.parse(JSON.stringify(crimeSceneAnswers)));
            console.log('Locations being checked:', currentCase.locationsV2.map(loc => ({
                position: loc.position,
                name: loc.name,
                alreadyCorrect: crimeSceneAnswers[`location${loc.position}`]
            })));
            
            currentCase.locationsV2.forEach((location, index) => {
                console.log(`\nChecking location at position ${location.position}: ${location.name}`);
                
                if (!crimeSceneAnswers[`location${location.position}`]) { // Only check if not already correct
                    const inputContainers = document.querySelectorAll(`#place${location.position} .input-container`);
                    console.log(`Found ${inputContainers.length} input containers for #place${location.position}`);
                    
                    if (inputContainers.length === 0) {
                        console.error(`No input container found for location position ${location.position}!`);
                        return;
                    }
                    
                    const wordGroups = inputContainers[0].querySelectorAll('.word-group');
                    
                    // Reconstruct the entered answer
                    let enteredAnswer = '';
                    wordGroups.forEach((group, groupIndex) => {
                        if (groupIndex > 0) enteredAnswer += ' '; // Add space between words
                        const letterBoxes = group.querySelectorAll('.letter-box');
                        letterBoxes.forEach(box => {
                            enteredAnswer += box.value.toUpperCase();
                        });
                    });
                    
                    // Check if answer is correct (with normalization support)
                    console.log(`Entered answer: "${enteredAnswer.trim()}" vs Expected: "${location.name}"`);
                    
                    if (checkLocationMatch(enteredAnswer.trim(), location.name)) {
                        console.log(`CORRECT! Marking location${location.position} as correct`);
                        
                        // Mark as correct
                        crimeSceneAnswers[`location${location.position}`] = true;
                        correctLocations[location.position - 1] = true; // Update global tracking
                        
                        // Score will be calculated at the end of the game
                        
                        // Lock the inputs and style them as correct
                        const letterBoxes = inputContainers[0].querySelectorAll('.letter-box');
                        letterBoxes.forEach(box => {
                            box.classList.add('correct');
                            box.disabled = true;
                        });
                    } else {
                        // Clear incorrect inputs
                        const letterBoxes = inputContainers[0].querySelectorAll('.letter-box');
                        letterBoxes.forEach(box => {
                            box.value = '';
                            box.classList.remove('filled');
                        });
                        console.log('Incorrect answer');
                    }
                } else {
                    console.log(`Skipping location${location.position} - already marked as correct`);
                }
            });
            
            console.log('Final crimeSceneAnswers state:', JSON.parse(JSON.stringify(crimeSceneAnswers)));
            console.log('=== checkCrimeSceneAnswers DEBUG END ===');
        }

        function checkFinalLocationAnswer() {
            if (!currentCase.finalLocationV2) return;
            
            // Get user input from phrase inputs
            const userInput = getUserPhraseInput();
            const expectedPhrase = puzzleState.phrase || currentCase.finalLocationV2.educationalPhrase || currentCase.finalLocationV2.name;
            
            // Check if answer is correct - EXACT match required for final location puzzle
            if (checkExactPhraseMatch(userInput.trim(), expectedPhrase)) {
                // Mark as correct
                finalLocationAnswer = true;
                correctLocations[3] = true; // Update global tracking (4th location)
                
                // Score will be calculated at the end of the game
                
                // Lock the inputs and style them as correct
                const letterInputs = document.querySelectorAll('.phrase-letter-input');
                letterInputs.forEach(input => {
                    input.classList.add('correct');
                    input.disabled = true;
                });
                
                // Hide torn paper letters
                const lettersContainer = document.getElementById('lettersContainer');
                if (lettersContainer) {
                    lettersContainer.style.display = 'none';
                }
                const shuffleBtn = document.querySelector('.shuffle-letters-btn');
                if (shuffleBtn) {
                    shuffleBtn.style.display = 'none';
                }
                
                // Show success and trigger game completion
                
            } else {
                // Wrong answer - let the main submitEvidence function handle turn progression
                // If we're in Turn 6 and about to advance to Turn 7, preserve correctly placed letters
                if (currentTurn === 6) {
                    preserveCorrectLettersForTurn7();
                } else {
                    // Turn 7 - clear all incorrect inputs (except hints)
                    const letterInputs = document.querySelectorAll('.phrase-letter-input:not(.hint-letter)');
                    letterInputs.forEach(input => {
                        input.value = '';
                        input.classList.remove('filled');
                    });
                    
                    // Recalculate remaining letters to match exactly what's missing
                    recalculateRemainingLetters();
                }
            }
        }

        // Recalculate remaining letters to match exactly what's missing from input boxes
        function recalculateRemainingLetters() {
            const allInputs = document.querySelectorAll('.phrase-letter-input');
            const expectedPhrase = puzzleState.phrase.toUpperCase();
            const expectedLetters = expectedPhrase.replace(/[^A-Z]/g, '').split('');
            
            // Calculate what letters are still needed
            const neededLetters = [];
            
            allInputs.forEach((input, index) => {
                if (index < expectedLetters.length) {
                    const expectedLetter = expectedLetters[index];
                    if (!input.value && expectedLetter) {
                        neededLetters.push(expectedLetter);
                    }
                }
            });
            
            // Update puzzle state
            puzzleState.remainingLetters = [...neededLetters];
            
            // Update used letters to include only currently filled letters
            const currentlyUsedLetters = [];
            allInputs.forEach(input => {
                if (input.value) {
                    currentlyUsedLetters.push(input.value.toUpperCase());
                }
            });
            
            puzzleState.usedLetters = [...currentlyUsedLetters];
            
            // Shuffle remaining letters for display
            puzzleState.remainingLetters = shuffleArray([...puzzleState.remainingLetters]);
            
            // Update the display
            displayLetterCards();
            
            console.log('Recalculated remaining letters:', puzzleState.remainingLetters);
            console.log('Current used letters:', puzzleState.usedLetters);
        }

        // Preserve correctly placed letters when advancing from Turn 6 to Turn 7
        function preserveCorrectLettersForTurn7() {
            const letterInputs = document.querySelectorAll('.phrase-letter-input');
            const expectedPhrase = puzzleState.phrase.toUpperCase();
            const expectedLetters = expectedPhrase.replace(/[^A-Z]/g, '').split('');
            
            letterInputs.forEach((input, index) => {
                const userLetter = input.value.toUpperCase();
                const expectedLetter = expectedLetters[index];
                
                if (userLetter && userLetter === expectedLetter) {
                    // This letter is correct - keep it and mark as hint
                    if (!input.classList.contains('hint-letter')) {
                        input.classList.add('hint-letter');
                        input.classList.add('turn7-hint'); // Special class for Turn 7 hints
                        input.readOnly = true;
                        
                        // Add to hint letters if not already there
                        if (!puzzleState.hintLetters.includes(userLetter)) {
                            puzzleState.hintLetters.push(userLetter);
                        }
                        
                        console.log(`Preserving correct letter "${userLetter}" at position ${index}`);
                    }
                } else if (userLetter) {
                    // This letter is incorrect - clear it
                    input.value = '';
                    input.classList.remove('filled');
                    
                    console.log(`Clearing incorrect letter "${userLetter}" at position ${index}, expected "${expectedLetter}"`);
                }
            });
            
            // Recalculate remaining letters to match exactly what's missing
            recalculateRemainingLetters();
            
            console.log(`Turn 7 hint: Preserved ${puzzleState.hintLetters.length} correct letters`);
        }


        // Show flag colors hint in Turn 7
        function showFlagColorsHint() {
            if (!currentCase.finalLocationV2.flagColors) return;
            
            const flagColorsHint = document.getElementById('flagColorsHint');
            const flagColors = JSON.parse(currentCase.finalLocationV2.flagColors);
            
            const swatchesHTML = flagColors.map(color => 
                `<div class="flag-color-swatch" style="background-color: ${color};" title="${color}"></div>`
            ).join('');
            
            flagColorsHint.innerHTML = `
                <strong>üè≥Ô∏è National Flag Colors:</strong><br>
                <div class="flag-colors-display">
                    ${swatchesHTML}
                </div>
                <small>These are the primary colors of the final location's national flag</small>
            `;
            flagColorsHint.style.display = 'block';
        }

        // Helper function to get user input from phrase inputs
        function getUserPhraseInput() {
            const inputs = document.querySelectorAll('.phrase-letter-input');
            
            let phrase = '';
            let currentWord = '';
            let lastWordIndex = -1;
            
            inputs.forEach((input, index) => {
                const wordIndex = parseInt(input.dataset.wordIndex);
                
                // If we're on a new word, add the previous word and a space
                if (wordIndex !== lastWordIndex && lastWordIndex !== -1) {
                    phrase += currentWord + ' ';
                    currentWord = '';
                }
                
                currentWord += input.value || '';
                lastWordIndex = wordIndex;
            });
            
            // Add the last word
            phrase += currentWord;
            
            return phrase.trim();
        }

        // Normalize text by removing accents and special characters
        function normalizeText(text) {
            // Convert to lowercase and trim
            text = text.toLowerCase().trim();
            
            // Remove accents and diacritical marks
            text = text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            
            // Common character replacements
            const replacements = {
                '√±': 'n',
                '√¶': 'ae',
                '≈ì': 'oe',
                '√∏': 'o',
                '√ü': 'ss',
                'ƒë': 'd',
                '√∞': 'd',
                '√æ': 'th',
                '≈Ç': 'l'
            };
            
            for (const [special, normal] of Object.entries(replacements)) {
                text = text.replace(new RegExp(special, 'g'), normal);
            }
            
            // Remove any remaining non-alphanumeric characters except spaces and hyphens
            text = text.replace(/[^a-z0-9\s-]/g, '');
            
            return text;
        }

        function checkExactPhraseMatch(answer, correct) {
            // Check for empty/blank answers first - these should never match
            if (!answer || !answer.trim()) {
                console.log('‚ùå Final location: Empty answer - no match');
                return false;
            }
            
            // Normalize both answer and correct phrase (handles international characters)
            const normalizedAnswer = normalizeText(answer);
            const normalizedCorrect = normalizeText(correct);
            
            // Also check against the original lowercase versions for exact matches
            const originalAnswer = answer.toLowerCase().trim();
            const originalCorrect = correct.toLowerCase().trim();
            
            // Debug logging for final location
            console.log('üîç Final Location Exact Match Debug:', {
                answer: answer,
                correct: correct,
                normalizedAnswer: normalizedAnswer,
                normalizedCorrect: normalizedCorrect,
                originalAnswer: originalAnswer,
                originalCorrect: originalCorrect
            });
            
            // Check for EXACT match only (no partial matching for final location puzzle)
            const exactMatch = normalizedAnswer === normalizedCorrect || 
                              originalAnswer === originalCorrect ||
                              answer.toLowerCase().trim() === correct.toLowerCase().trim();
            
            console.log('üîç Final location exact match result:', exactMatch);
            return exactMatch;
        }

        function checkLocationMatch(answer, correct) {
            // Check for empty/blank answers first - these should never match
            if (!answer || !answer.trim()) {
                console.log('‚ùå Empty answer - no match');
                return false;
            }
            
            // Normalize both answer and correct name
            const normalizedAnswer = normalizeText(answer);
            const normalizedCorrect = normalizeText(correct);
            
            // Also check against the original lowercase versions for exact matches
            const originalAnswer = answer.toLowerCase().trim();
            const originalCorrect = correct.toLowerCase().trim();
            
            // Debug logging
            console.log('üîç City Match Debug:', {
                answer: answer,
                correct: correct,
                normalizedAnswer: normalizedAnswer,
                normalizedCorrect: normalizedCorrect,
                originalAnswer: originalAnswer,
                originalCorrect: originalCorrect
            });
            
            // Check for exact match (normalized or original, case insensitive)
            if (normalizedAnswer === normalizedCorrect || 
                originalAnswer === originalCorrect ||
                answer.toLowerCase().trim() === correct.toLowerCase().trim()) {
                    return true;
            }
            
            // Check for partial matches (both normalized and original)
            // Only do partial matching if both strings have substantial length
            if (normalizedAnswer.length >= 3 && normalizedCorrect.length >= 3) {
                const partialMatch = normalizedAnswer.includes(normalizedCorrect) ||
                       normalizedCorrect.includes(normalizedAnswer) ||
                       originalAnswer.includes(originalCorrect) ||
                       originalCorrect.includes(originalAnswer);
                
                console.log('üîç Partial match result:', partialMatch);
                return partialMatch;
            }
            
            console.log('‚ùå No match found');
            return false;
        }

        function showCrimeSceneFeedback(results) {
            ['location1', 'location2', 'location3'].forEach(key => {
                const feedbackElement = document.getElementById(`feedback${key.slice(-1)}`);
                if (results[key]) {
                    feedbackElement.textContent = '‚úì Correct';
                    feedbackElement.className = 'input-feedback correct';
                    document.getElementById(key).disabled = true;
                    document.getElementById(key).classList.add('correct');
                } else {
                    feedbackElement.textContent = '‚úó Incorrect';
                    feedbackElement.className = 'input-feedback incorrect';
                }
            });
        }

        // Helper function to add category hint to Final Challenge box
        function addCategoryHintToFinalChallenge() {
            const puzzleInstructions = document.querySelector('.puzzle-instructions');
            
            if (puzzleInstructions && currentTurn >= 6 && currentCase.finalLocationV2 && currentCase.finalLocationV2.categoryHint) {
                // Check if category hint already exists to avoid duplicates
                if (!puzzleInstructions.querySelector('.category-hint-display')) {
                    const categoryHintDiv = document.createElement('div');
                    categoryHintDiv.className = 'category-hint-display';
                    categoryHintDiv.innerHTML = `
                        <div class="category-hint-header">üí° Hint:</div>
                        <div class="category-hint-value">${currentCase.finalLocationV2.categoryHint}</div>
                        <div class="category-hint-description">This hint reveals what the phrase is about.</div>
                    `;
                    puzzleInstructions.appendChild(categoryHintDiv);
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }

        function unlockFinalLocationPhase() {
            gameState = 'crimes_solved';
            
            // Update objective description based on final location objective
            const objectiveMap = {
                'WHERE_STASHED': 'where did the villain stash the stolen goods?',
                'NEXT_TARGET': 'where will the villain strike next?',
                'VILLAIN_HIDEOUT': 'where is the villain hiding?',
                'EVIDENCE_SOURCE': 'where did the key evidence originate?',
                'VILLAIN_HOMETOWN': 'where is the villain originally from?',
                'ACCOMPLICE_LOCATION': 'where is the villain\'s partner located?',
                'ESCAPE_ROUTE': 'where does the villain plan to flee?',
                'FAMILY_TIES': 'where are the villain\'s family connections?',
                'TREASURE_DESTINATION': 'where does the villain plan to sell the goods?',
                'VILLAIN_INSPIRATION': 'what location inspired the crime spree?',
                'FINAL_HEIST': 'what is the villain\'s ultimate target?',
                'CRIME_ORIGIN': 'where did the villain learn their skills?',
                'RETIREMENT_PLAN': 'where does the villain plan to retire?'
            };
            
            const description = objectiveMap[currentCase.finalLocationObjective] || 'where is the final location?';
            // Removed finalObjectiveDescription update as element was combined with Final Challenge header
            
            // Hide crime scene phase when final location is unlocked (focus on final location puzzle)
            document.getElementById('crimeScenePhase').classList.add('hidden');
            
            // Hide crime scene description and show final location instructions
            document.getElementById('crimeSceneDescription').classList.add('hidden');
            document.getElementById('finalLocationInstructions').classList.remove('hidden');
            
            // Add category hint to Final Challenge box if we're in Turn 6 or later
            addCategoryHintToFinalChallenge();
            
            // Generate final location letter boxes
            generateFinalLocationInput();
            
            // Show final location phase
            document.getElementById('finalLocationPhase').classList.remove('hidden');
        }

        function updateActionButton() {
            const actionButton = document.getElementById('actionButton');
            
            if (gameState === 'investigating_crimes') {
                // Crime scene phase
                actionButton.textContent = `Turn ${currentTurn} Check`;
                actionButton.className = `action-button turn-${currentTurn}`;
            } else if (gameState === 'final_investigation') {
                // Final location phase
                actionButton.textContent = `Turn ${currentTurn} Check`;
                actionButton.className = `action-button turn-${currentTurn}`;
            } else if (gameState === 'case_complete') {
                actionButton.style.display = 'none';
            }
        }

        function revealRemainingCrimeTurns() {
            // Show all remaining turns 1-5 instantly
            for (let turn = currentTurn + 1; turn <= 5; turn++) {
                displayV2Turn(turn);
            }
            currentTurn = 5;
            updateV2TurnDisplay();
        }

        function addFinalLocationTurns() {
            gameState = 'final_investigation';
            
            // Show final location section
            document.getElementById('finalLocationSection').classList.remove('hidden');
            
            // Start with turn 6
            setTimeout(() => {
                currentTurn = 6;
                // Don't call displayV2Turn(6) as Turn 6 doesn't exist in database
                // Just update the turn display and action button
                updateV2TurnDisplay();
                updateActionButton();
                
                // Add category hint to Final Challenge box if it exists
                addCategoryHintToFinalChallenge();
                
                // Recalculate remaining letters to match exactly what's missing
                recalculateRemainingLetters();
                
                // Show flag colors hint in Turn 6
                const flagColorsHint = document.getElementById('flagColorsHint');
                if (flagColorsHint && currentCase.finalLocationV2.flagColors) {
                    try {
                        const flagColors = JSON.parse(currentCase.finalLocationV2.flagColors);
                        let flagHtml = '<strong>üè≥Ô∏è National Flag Colors:</strong><div class="flag-colors-display">';
                        flagColors.forEach(color => {
                            flagHtml += `<div class="flag-color-swatch" style="background-color: ${color}" title="${color}"></div>`;
                        });
                        flagHtml += '</div><small>These are the primary colors of the final location\'s national flag</small>';
                        flagColorsHint.innerHTML = flagHtml;
                        flagColorsHint.style.display = 'block';
                    } catch (e) {
                        console.error('Error parsing flag colors:', e);
                    }
                }
            }, 1000);
        }

        function checkFinalLocation() {
            const finalAnswer = document.getElementById('finalLocationInput').value.trim();
            const correctAnswer = currentCase.finalLocationV2.name;
            
            const isCorrect = checkLocationMatch(finalAnswer, correctAnswer);
            
            if (isCorrect) {
                finalLocationAnswer = true;
                showCaseComplete();
                stopTimer();
            } else {
                showFinalLocationFeedback(false);
            }
        }

        function showFinalLocationFeedback(isCorrect) {
            const feedbackElement = document.getElementById('finalFeedback');
            if (isCorrect) {
                feedbackElement.textContent = '‚úì Correct';
                feedbackElement.className = 'input-feedback correct';
                document.getElementById('finalLocationInput').disabled = true;
                document.getElementById('finalLocationInput').classList.add('correct');
            } else {
                feedbackElement.textContent = '‚úó Incorrect';
                feedbackElement.className = 'input-feedback incorrect';
            }
        }

        function calculateFinalScore() {
            const allCrimeLocationsCorrect = correctLocations[0] && correctLocations[1] && correctLocations[2];
            const finalLocationCorrect = correctLocations[3];
            const correctCrimeLocationsCount = correctLocations.slice(0, 3).filter(correct => correct).length;
            
            const timeTaken = gameTimer;
            const difficulty = currentCase.difficulty || 'medium';
            
            let baseScore = 0;
            
            // Base scoring according to new system
            if (finalLocationCorrect && allCrimeLocationsCorrect) {
                // Finished the game completely
                if (currentTurn === 6) {
                    baseScore = 2000; // Finished in 6 turns
                } else if (currentTurn === 7) {
                    baseScore = 1500; // Finished in 7 turns
                }
            } else if (allCrimeLocationsCorrect) {
                // Got 3 locations but not the 4th
                baseScore = 1000;
            } else if (correctCrimeLocationsCount === 2) {
                // Got 2 initial locations right
                baseScore = 500;
            } else if (correctCrimeLocationsCount === 1) {
                // Got only 1 initial location right
                baseScore = 250;
            }
            
            // Apply difficulty bonus
            if (difficulty === 'medium') {
                baseScore += 250;
            } else if (difficulty === 'hard') {
                baseScore += 500;
            }
            
            // Apply time bonus (under 5 minutes = 300 seconds)
            if (timeTaken < 300 && baseScore > 0) {
                baseScore += 250;
            }
            
            return baseScore;
        }

        function endGameV2(result) {
            // Stop timer
            stopTimer();
            
            const allCrimeLocationsCorrect = correctLocations[0] && correctLocations[1] && correctLocations[2];
            const finalLocationCorrect = correctLocations[3];
            const allLocationsCorrect = allCrimeLocationsCorrect && finalLocationCorrect;
            
            const timeTaken = gameTimer;
            const minutes = Math.floor(timeTaken / 60);
            const seconds = timeTaken % 60;
            
            // Calculate final score using new system
            gameScore = calculateFinalScore();
            
            console.log(`Final score calculated: ${gameScore} points`);
            console.log(`Game completed in ${minutes}:${seconds.toString().padStart(2, '0')}`);
            console.log(`Difficulty: ${currentCase.difficulty || 'medium'}`);
            console.log(`Correct locations: ${correctLocations.slice(0, 3).filter(correct => correct).length}/3 crime scenes, ${correctLocations[3] ? '1' : '0'}/1 final location`);
            
            let modalContent = '';
            let headerText = '';
            
            if (result === 'captured') {
                // All locations correct - show CAPTURED
                headerText = 'CASE CLOSED';
                modalContent = `
                    <div class="villain-capture">
                        <img src="${currentCase.villainImageUrl}" alt="${currentCase.villainName}" class="villain-capture-image">
                        <div class="captured-stamp">CAPTURED</div>
                    </div>
                    <h2 class="villain-capture-title">${currentCase.villainName}</h2>
                    <p class="villain-capture-subtitle">"${currentCase.villainTitle}"</p>
                `;
            } else {
                // Suspect escaped
                headerText = 'CASE CLOSED';
                let escapeReason = '';
                if (result === 'escaped_unsolved') {
                    escapeReason = 'Failed to identify all crime scene locations in time.';
                } else if (result === 'escaped_final') {
                    escapeReason = 'Failed to locate the suspect\'s final hideout.';
                }
                
                modalContent = `
                    <div class="villain-capture escape-layout">
                        <div class="villain-image-container">
                            <img src="${currentCase.villainImageUrl}" alt="${currentCase.villainName}" class="villain-capture-image">
                        </div>
                        <div class="escape-message">
                            <h2 class="villain-escape-title">SUSPECT ESCAPES CAPTURE!</h2>
                            <p class="villain-escape-subtitle">${escapeReason}</p>
                            <p class="try-again-text">The suspect remains at large. Try again to capture them!</p>
                        </div>
                    </div>
                    <div class="villain-info">
                        <h3 class="villain-info-title">${currentCase.villainName}</h3>
                        <p class="villain-info-subtitle">"${currentCase.villainTitle}"</p>
                    </div>
                `;
            }
            
            // Add statistics
            modalContent += `
                <div class="game-stats-compact">
                    <div class="stat-row score-total">
                        <span class="stat-label">Score:</span>
                        <span class="stat-value">${gameScore} points</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Time:</span>
                        <span class="stat-value">${minutes}:${seconds.toString().padStart(2, '0')}</span>
                    </div>
                </div>
            `;
            
            // Add sign-in prompt if user is not signed in, or confirmation if signed in
            if (!currentUser) {
                modalContent += `
                    <div class="sign-in-prompt">
                        <p class="sign-in-message">Sign in to save your score and track your progress!</p>
                        <button class="action-button sign-in-button" onclick="signIn()">
                            Sign In
                        </button>
                    </div>
                `;
            } else {
                modalContent += `
                    <div class="score-recorded-prompt">
                        <p class="score-recorded-message">‚úì Score recorded for ${currentUser.username || currentUser.name}</p>
                    </div>
                `;
            }
            
            if (result === 'captured') {
                const interestingFact = currentCase.finalLocationV2?.interestingFact || currentCase.finalInterestingFact || 'Amazing detective work!';
                modalContent += `
                    <div class="interesting-fact-section">
                        <h3 class="interesting-fact-title">üß≠ Did You Know?</h3>
                        <p class="interesting-fact">${interestingFact}</p>
                    </div>
                `;
            }
            
            // Add the Start New Case button to the modal content
            modalContent += `
                <div class="end-game-actions">
                    <button class="action-button end-game-button" onclick="playAgain()">
                        Start New Case
                    </button>
                </div>
            `;
            
            // Update modal
            document.getElementById('endGameHeader').textContent = headerText;
            document.getElementById('endGameContent').innerHTML = modalContent;
            document.getElementById('endGameModal').classList.add('show');
            
            // Save game result
            saveGameResultV2(result === 'captured', timeTaken, gameScore, currentTurn, finalLocationCorrect);
        }

        async function saveGameResultV2(success, timeTaken, score, turnsUsed, finalLocationCorrect) {
            
            const gameResult = {
                caseId: currentCase.id,
                success: success,
                timeTaken: timeTaken,
                score: score,
                turnsUsed: turnsUsed,
                date: new Date().toISOString(),
                correctLocations: correctLocations
            };
            
            // Always save to localStorage as backup with size limits
            try {
                const MAX_RESULTS = 100; // Limit to prevent memory bloat
                
                let savedResults = JSON.parse(localStorage.getItem('gameResultsV2') || '[]');
                savedResults.push(gameResult);
                
                // Keep only the most recent results
                if (savedResults.length > MAX_RESULTS) {
                    savedResults = savedResults.slice(-MAX_RESULTS);
                }
                
                localStorage.setItem('gameResultsV2', JSON.stringify(savedResults));
                
                // Save to user-specific localStorage
                if (currentUser) {
                    const userKey = `userResults_${currentUser.id}`;
                    let userResults = JSON.parse(localStorage.getItem(userKey) || '[]');
                    
                    // Add additional fields for compatibility with gallery
                    const userResult = {
                        ...gameResult,
                        captured: success, // For compatibility with V1 format
                        gameId: currentCase.id, // Alternative field name
                        pointsEarned: score,
                        userId: currentUser.id,
                        userName: currentUser.username || currentUser.name
                    };
                    
                    userResults.push(userResult);
                    
                    // Keep only the most recent user results
                    if (userResults.length > MAX_RESULTS) {
                        userResults = userResults.slice(-MAX_RESULTS);
                    }
                    
                    localStorage.setItem(userKey, JSON.stringify(userResults));
                }
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
            }
            
            // Save to database if user is logged in
            if (currentUser && currentCase) {
                
                try {
                    const response = await fetch(`/api/v2/games/${currentCase.id}/submit-result`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            playerId: currentUser.id,
                            playerEmail: currentUser.email,
                            playerUsername: currentUser.username || currentUser.name,
                            solvedLocations: correctLocations.filter(Boolean).length >= 3,
                            solvedFinal: finalLocationCorrect || false,
                            pointsEarned: score || 0,
                            turnsUsed: turnsUsed || 0,
                            timeTaken: timeTaken || 0
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        // Game result saved successfully
                    } else {
                        const errorData = await response.json();
                        console.error('Failed to save to database:', errorData.error);
                    }
                } catch (error) {
                    console.error('Network error saving to database:', error);
                    
                    // Save to session storage for retry later
                    try {
                        sessionStorage.setItem('pendingGameResultV2', JSON.stringify({
                            gameId: currentCase.id,
                            playerId: currentUser.id,
                            playerEmail: currentUser.email,
                            playerUsername: currentUser.username || currentUser.name,
                            solvedLocations: correctLocations.filter(Boolean).length >= 3,
                            solvedFinal: finalLocationCorrect || false,
                            pointsEarned: score || 0,
                            turnsUsed: turnsUsed || 0,
                            timeTaken: timeTaken || 0,
                            timestamp: new Date().toISOString()
                        }));
                        console.log('üíæ Result saved to session storage for retry');
                    } catch (sessionError) {
                        console.error('Failed to save to session storage:', sessionError);
                    }
                }
            } else {
                if (!currentUser) {
                    console.warn('‚ö†Ô∏è  USER NOT SIGNED IN - Score will NOT appear on leaderboard!');
                    console.warn('‚ö†Ô∏è  Sign in via the user menu to save scores to database');
                } else if (!currentCase) {
                    console.error('‚ùå No current case data available');
                }
                console.log('‚ÑπÔ∏è  Result saved locally only (not submitted to leaderboard)');
            }
        }


        function updateHeaderForUser() {
            // Update the header to show signed-in state
            setTimeout(() => {
                if (currentUser) {
                    // Update user menu button text
                    const userMenuText = document.getElementById('userMenuText');
                    if (userMenuText) {
                        userMenuText.textContent = currentUser.username || currentUser.name || 'User';
                    }
                    
                    // Show signed-in menu, hide signed-out menu
                    const signedOutMenu = document.getElementById('signedOutMenu');
                    const signedInMenu = document.getElementById('signedInMenu');
                    const menuUserName = document.getElementById('menuUserName');
                    
                    if (signedOutMenu) signedOutMenu.classList.add('hidden');
                    if (signedInMenu) signedInMenu.classList.remove('hidden');
                    if (menuUserName) menuUserName.textContent = currentUser.username || currentUser.name || 'Detective';
                    
                    }
            }, 200);
        }

        function closeEndGameModal() {
            document.getElementById('endGameModal').classList.remove('show');
        }

        function updateEndGameModalSignInStatus() {
            // Check if the end game modal is currently shown
            const endGameModal = document.getElementById('endGameModal');
            if (!endGameModal || !endGameModal.classList.contains('show')) {
                return; // Modal is not shown, no need to update
            }

            // Find the sign-in/score-recorded section in the modal
            const signInPrompt = document.querySelector('.sign-in-prompt');
            const scoreRecordedPrompt = document.querySelector('.score-recorded-prompt');
            
            if (currentUser) {
                // User is now signed in - replace sign-in prompt with score recorded message
                if (signInPrompt) {
                    signInPrompt.outerHTML = `
                        <div class="score-recorded-prompt">
                            <p class="score-recorded-message">‚úì Score recorded for ${currentUser.username || currentUser.name}</p>
                        </div>
                    `;
                }
            } else {
                // User signed out - replace score recorded message with sign-in prompt
                if (scoreRecordedPrompt) {
                    scoreRecordedPrompt.outerHTML = `
                        <div class="sign-in-prompt">
                            <p class="sign-in-message">Sign in to save your score and track your progress!</p>
                            <button class="action-button sign-in-button" onclick="signIn()">
                                Sign In
                            </button>
                        </div>
                    `;
                }
            }
        }

        function playAgain() {
            window.location.href = 'index.html';
        }

        function showCaseComplete() {
            gameState = 'case_complete';
            
            // Hide other phases
            document.getElementById('crimeScenePhase').classList.add('hidden');
            document.getElementById('finalLocationPhase').classList.add('hidden');
            
            // Show completion
            const completionElement = document.getElementById('caseComplete');
            completionElement.classList.remove('hidden');
            
            // Set completion message
            document.getElementById('completionMessage').textContent = currentCase.gameCompletionMessage;
            const interestingFact = currentCase.finalLocationV2?.interestingFact || currentCase.finalInterestingFact || 'Amazing detective work!';
            document.getElementById('finalFact').textContent = interestingFact;
            
            // Show time
            const minutes = Math.floor(gameTimer / 60);
            const seconds = gameTimer % 60;
            document.getElementById('finalTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateV2TurnDisplay() {
            const dots = document.querySelectorAll('.turn-dot');
            const progressFill = document.getElementById('progressFill');
            
            // Update progress bar (0-100% for turns 1-7)
            const progress = Math.min((currentTurn / 7) * 100, 100);
            progressFill.style.width = progress + '%';
            
            // Update turn dots
            dots.forEach((dot, index) => {
                const turnNumber = index + 1;
                dot.classList.remove('active', 'completed');
                
                if (turnNumber < currentTurn) {
                    dot.classList.add('completed');
                } else if (turnNumber === currentTurn) {
                    dot.classList.add('active');
                }
            });
        }

        function createConnectionWeb(distances, timeDiffs) {
            try {
                // Extract distance data from stored clues
                const distanceMap = {};
                distances.forEach(d => {
                    const data = typeof d.data === 'string' ? JSON.parse(d.data) : d.data;
                    if (data && data.between && data.kilometers) {
                        const key = `${data.between[0]}-${data.between[1]}`;
                        distanceMap[key] = data.kilometers;
                    }
                });
                
                // Extract time difference data from stored clues
                const timeMap = {};
                timeDiffs.forEach(t => {
                    const data = typeof t.data === 'string' ? JSON.parse(t.data) : t.data;
                    if (data && data.between) {
                        const key = `${data.between[0]}-${data.between[1]}`;
                        // Extract hours from content string like "6 hours difference" or "1 hour difference"
                        const match = t.content.match(/(\d+)\s*hours?\s*difference/i);
                        if (match) {
                            timeMap[key] = parseInt(match[1]);
                        }
                    }
                });
                
                // Get longitude coordinates for west-to-east ordering
                const locationCoords = {};
                if (window.currentCase && window.currentCase.locationsV2) {
                    window.currentCase.locationsV2.forEach(loc => {
                        locationCoords[loc.position] = loc.longitude;
                    });
                }
                
                // Sort locations by longitude (west to east: negative to positive)
                const sortedLocations = [1, 2, 3].sort((a, b) => {
                    const lonA = locationCoords[a] || 0;
                    const lonB = locationCoords[b] || 0;
                    return lonA - lonB; // Sort west to east
                });
                
                console.log('Location coordinates:', locationCoords);
                console.log('Sorted locations (west to east):', sortedLocations);
                console.log('Distance map:', distanceMap);
                console.log('Time map:', timeMap);
                
                // Check if we have all required data
                if (Object.keys(distanceMap).length !== 3 || Object.keys(timeMap).length !== 3) {
                    console.warn('Missing distance or time data for diagram', {
                        distanceKeys: Object.keys(distanceMap),
                        timeKeys: Object.keys(timeMap)
                    });
                }
                
                // Helper function to get stored distance between places
                const getStoredDistance = (from, to) => {
                    const key1 = `${from}-${to}`;
                    const key2 = `${to}-${from}`;
                    return distanceMap[key1] || distanceMap[key2] || 0;
                };
                
                // Helper function to get stored time difference between places
                const getStoredTimeDiff = (from, to) => {
                    const key1 = `${from}-${to}`;
                    const key2 = `${to}-${from}`;
                    // Return the exact stored value, don't reverse it
                    return timeMap[key1] !== undefined ? timeMap[key1] : (timeMap[key2] !== undefined ? timeMap[key2] : 0);
                };
                
                const westPlace = sortedLocations[0];   // Westernmost
                const middlePlace = sortedLocations[1]; // Middle  
                const eastPlace = sortedLocations[2];   // Easternmost
                
                // Calculate signed time differences based on timezone offsets
                // When going west to east, positive means ahead in time
                const getSignedTimeDiff = (fromPos, toPos) => {
                    // Manual mapping of UTC offsets for locations if timezoneOffset is not available
                    const getUTCOffset = (position) => {
                        const location = currentCase.locationsV2.find(l => l.position === position);
                        
                        // If timezoneOffset is available and not 0, use it
                        if (location && location.timezoneOffset !== undefined && location.timezoneOffset !== 0) {
                            return location.timezoneOffset;
                        }
                        
                        // Otherwise, extract from timezone string or city name
                        if (location && location.timezone) {
                            const tzMap = {
                                'Africa/Accra': 0,
                                'America/Lima': -5,
                                'Asia/Bangkok': 7,
                                'Asia/Ho_Chi_Minh': 7,
                                'Asia/Saigon': 7,
                                'Asia/Jakarta': 7,
                                'Asia/Manila': 8,
                                'Asia/Shanghai': 8,
                                'Asia/Tokyo': 9,
                                'America/New_York': -5,
                                'America/Chicago': -6,
                                'America/Denver': -7,
                                'America/Los_Angeles': -8,
                                'Europe/London': 0,
                                'Europe/Paris': 1,
                                'Europe/Berlin': 1,
                                'Europe/Moscow': 3,
                                'Australia/Sydney': 10,
                                'Australia/Melbourne': 10
                            };
                            
                            if (tzMap[location.timezone]) {
                                return tzMap[location.timezone];
                            }
                        }
                        
                        // Fallback to 0 if no mapping found
                        return 0;
                    };
                    
                    const fromTZ = getUTCOffset(fromPos);
                    const toTZ = getUTCOffset(toPos);
                    console.log(`Time difference calculation: Position ${fromPos} (UTC${fromTZ}) -> Position ${toPos} (UTC${toTZ}) = ${toTZ - fromTZ}h`);
                    return toTZ - fromTZ;
                };
                
                // Get time differences between adjacent places in west-to-east order
                const timeWestToMiddle = getSignedTimeDiff(westPlace, middlePlace);
                const timeMiddleToEast = getSignedTimeDiff(middlePlace, eastPlace);
                const timeWestToEast = getSignedTimeDiff(westPlace, eastPlace);
                
                // Get all distances
                const distWestMiddle = getStoredDistance(westPlace, middlePlace);
                const distMiddleEast = getStoredDistance(middlePlace, eastPlace);
                const distWestEast = getStoredDistance(westPlace, eastPlace);
            
            // Calculate distance in miles for each pair
            const distWestMiddleMiles = Math.round(distWestMiddle * 0.621371);
            const distMiddleEastMiles = Math.round(distMiddleEast * 0.621371);
            const distWestEastMiles = Math.round(distWestEast * 0.621371);
            
            // Format time differences with +/- symbols
            const formatTimeDiff = (hours) => {
                return hours > 0 ? `+${hours}h` : hours < 0 ? `${hours}h` : '0h';
            };

            // Format time difference as English text with HTML styling
            const formatTimeEnglish = (hours, fromCity, toCity) => {
                if (hours === 0) {
                    return `${toCity} is in the same time zone as ${fromCity}`;
                } else if (hours > 0) {
                    const hoursText = hours === 1 ? 'hour' : 'hours';
                    return `${toCity} is <span style="color: #FF4500; font-weight: 700;">${hours} ${hoursText}</span> ahead of ${fromCity}`;
                } else {
                    const absHours = Math.abs(hours);
                    const hoursText = absHours === 1 ? 'hour' : 'hours';
                    return `${toCity} is <span style="color: #FF4500; font-weight: 700;">${absHours} ${hoursText}</span> behind ${fromCity}`;
                }
            };

            return `
                <div class="geographic-flow-display">
                    <!-- Distance Information -->
                    <div style="background: rgba(26, 91, 91, 0.1); border: 2px solid #1A5B5B; border-radius: 12px; padding: 16px;">
                        <h4 style="font-family: 'Courier New', monospace; font-size: 14px; font-weight: 700; color: #1A5B5B; margin: 0 0 12px 0; text-align: center; text-transform: uppercase;">
                            üìè Distances Between Cities
                        </h4>
                        
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px; font-family: 'Courier New', monospace;">
                            <div style="text-align: center; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #1A5B5B;">
                                <div style="font-weight: 700; color: #1A5B5B; font-size: 14px;">City ${westPlace} ‚Üî City ${middlePlace}</div>
                                <div style="font-weight: 700; color: #FF4500; font-size: 13px; margin-top: 2px;">${distWestMiddle.toLocaleString()} km / ${distWestMiddleMiles.toLocaleString()} miles</div>
                            </div>
                            
                            <div style="text-align: center; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #FF4500;">
                                <div style="font-weight: 700; color: #1A5B5B; font-size: 14px;">City ${middlePlace} ‚Üî City ${eastPlace}</div>
                                <div style="font-weight: 700; color: #FF4500; font-size: 13px; margin-top: 2px;">${distMiddleEast.toLocaleString()} km / ${distMiddleEastMiles.toLocaleString()} miles</div>
                            </div>
                            
                            <div style="text-align: center; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #1A1A1A;">
                                <div style="font-weight: 700; color: #1A5B5B; font-size: 14px;">City ${westPlace} ‚Üî City ${eastPlace}</div>
                                <div style="font-weight: 700; color: #FF4500; font-size: 13px; margin-top: 2px;">${distWestEast.toLocaleString()} km / ${distWestEastMiles.toLocaleString()} miles</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Time Zone Analysis -->
                    <div style="background: rgba(255, 69, 0, 0.1); border: 2px solid #FF4500; border-radius: 12px; padding: 16px; margin-top: 16px;">
                        <h4 style="font-family: 'Courier New', monospace; font-size: 14px; font-weight: 700; color: #FF4500; margin: 0 0 12px 0; text-align: center; text-transform: uppercase;">
                            üïê Time Zone Analysis
                        </h4>
                        
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px; font-family: 'Courier New', monospace;">
                            <div style="text-align: left; padding: 12px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #FF4500;">
                                <div style="font-weight: 700; color: #000; font-size: 14px;">${formatTimeEnglish(timeWestToMiddle, `City ${westPlace}`, `City ${middlePlace}`)}</div>
                            </div>
                            
                            <div style="text-align: left; padding: 12px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #FF4500;">
                                <div style="font-weight: 700; color: #000; font-size: 14px;">${formatTimeEnglish(timeMiddleToEast, `City ${middlePlace}`, `City ${eastPlace}`)}</div>
                            </div>
                            
                            <div style="text-align: left; padding: 12px; background: rgba(255, 255, 255, 0.9); border-radius: 6px; border-left: 4px solid #FF4500;">
                                <div style="font-weight: 700; color: #000; font-size: 14px;">${formatTimeEnglish(timeWestToEast, `City ${westPlace}`, `City ${eastPlace}`)}</div>
                            </div>
                        </div>
                        
                        <div style="font-family: 'Courier New', monospace; font-size: 12px; color: #333; text-align: center; line-height: 1.6; margin-top: 12px; padding-top: 12px; border-top: 2px solid #FF4500;">
                            <p style="margin: 0; font-size: 11px; color: #666;">
                                Time zone differences help determine the east-west positioning of cities around the world.
                            </p>
                        </div>
                    </div>
                </div>
            `;
            } catch (error) {
                console.error('Error creating connection web:', error);
                return '';
            }
        }
        
        function startElapsedTimer() {
            if (timerInterval) clearInterval(timerInterval);
            
            timerInterval = setInterval(() => {
                gameTimer++;
                updateTimerDisplay();
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameTimer / 60);
            const seconds = gameTimer % 60;
            const timerValue = document.getElementById('timerValue');
            if (timerValue) {
                timerValue.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerValue.style.color = 'var(--primary-orange)';
                timerValue.style.borderColor = 'var(--primary-orange)';
            }
        }

        function stopTimer() {
            if (timerInterval) clearInterval(timerInterval);
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            if (tabName === 'caseDetails') {
                document.getElementById('caseDetailsTab').classList.add('active');
                document.getElementById('caseDetailsPanel').classList.add('active');
            } else if (tabName === 'investigation') {
                document.getElementById('investigationTab').classList.add('active');
                document.getElementById('investigationPanel').classList.add('active');
                // Initialize with appropriate view based on what's available
                const dropdown = document.getElementById('viewDropdown');
                const distancesOption = document.getElementById('distancesOption');
                
                if (distancesOption.style.display !== 'none') {
                    // If distances are available, show distances view
                    dropdown.value = 'distances';
                    switchView();
                } else {
                    // Otherwise default to first city
                    dropdown.value = 'location1';
                    switchView();
                }
            } else if (tabName === 'answers') {
                document.getElementById('answersTab').classList.add('active');
                document.getElementById('answersPanel').classList.add('active');
            }
            
            activeTab = tabName;
        }

        function switchView() {
            const dropdown = document.getElementById('viewDropdown');
            const selectedValue = dropdown.value;
            
            // Hide all views
            document.querySelectorAll('.evidence-view').forEach(view => {
                view.classList.add('hidden');
            });
            
            // Show selected view and update content
            const viewId = selectedValue + 'View';
            document.getElementById(viewId).classList.remove('hidden');
            
            switch (selectedValue) {
                case 'distances':
                    updateDistancesView();
                    break;
                case 'location1':
                    updateLocationEvidence(1);
                    break;
                case 'location2':
                    updateLocationEvidence(2);
                    break;
                case 'location3':
                    updateLocationEvidence(3);
                    break;
            }
        }

        function updateDistancesView() {
            const container = document.getElementById('distancesContent');
            if (!currentCase || !window.v2TimelineEntries) {
                container.innerHTML = '<div class="no-evidence">No investigation data available yet.</div>';
                return;
            }
            
            let html = '';
            
            // Only show Turn 4 content for Distances view
            const turn4 = window.v2TimelineEntries.find(t => t.turn === 4);
            
            if (!turn4) {
                container.innerHTML = '<div class="no-evidence">No distance information available yet.</div>';
                return;
            }
            
            const distances = turn4.clues.filter(c => c.type === 'distance');
            const timeDiffs = turn4.clues.filter(c => c.type === 'time_difference');
            
            if (distances.length === 3 && timeDiffs.length === 3) {
                html += `<div class="location-header">
                    <h4>Geographic Analysis</h4>
                    <p class="location-subtitle">Distances and time differences between cities</p>
                </div>`;
                
                html += `<div class="timeline-entry clue-entry distance-diagram-entry">`;
                html += `<div class="clue-header">üï∏Ô∏è Connection Analysis</div>`;
                html += `<div class="distance-diagram-container">`;
                html += createConnectionWeb(distances, timeDiffs);
                html += `</div></div>`;
            } else {
                html = '<div class="no-evidence">Distance and timezone data not yet available.</div>';
            }
            
            container.innerHTML = html;
        }

        function updateLocationEvidence(locationPosition) {
            const container = document.getElementById(`location${locationPosition}Evidence`);
            if (!currentCase || !window.v2TimelineEntries) {
                container.innerHTML = '<div class="no-evidence">No evidence available for this city yet.</div>';
                return;
            }
            
            let html = '';
            const locationClues = [];
            
            // Gather ALL clues for this location (including general ones)
            window.v2TimelineEntries.forEach(turn => {
                if (turn.turn <= currentTurn) {
                    turn.clues.forEach(clue => {
                        let appliesHere = false;
                        
                        // Check if clue applies to this location
                        if (clue.locationPositions) {
                            try {
                                const positions = JSON.parse(clue.locationPositions);
                                appliesHere = positions.includes(locationPosition);
                            } catch (e) {
                                // If parsing fails, check if it's a general clue
                                appliesHere = false;
                            }
                        } else if (clue.type === 'image') {
                            // For image clues, check if they belong to this location
                            const location = currentCase.locationsV2.find(loc => 
                                loc.position === locationPosition && loc.hasImage && loc.imageTurn === turn.turn
                            );
                            appliesHere = !!location;
                        } else {
                            // For clues without location positions, check if they're general/theme clues
                            // that should be shown everywhere (like distance, theme, etc.)
                            if (['theme', 'distance', 'time_difference'].includes(clue.type)) {
                                appliesHere = false; // These are handled in Distances view
                            } else {
                                // For other clues without location data, show them as they might be relevant
                                appliesHere = true;
                            }
                        }
                        
                        if (appliesHere) {
                            locationClues.push({
                                ...clue, 
                                turnNumber: turn.turn,
                                narrative: turn.narrative
                            });
                        }
                    });
                }
            });
            
            if (locationClues.length > 0) {
                html += `<div class="location-header">
                    <h4>City ${locationPosition} Evidence</h4>
                    <p class="location-subtitle">Evidence and clues related to this city</p>
                </div>`;
                
                locationClues.forEach(clue => {
                    html += renderLocationClue(clue);
                });
            } else {
                html = `<div class="no-evidence">
                    <h4>City ${locationPosition}</h4>
                    <p>No specific evidence for this city has been discovered yet.</p>
                    <p class="hint">Continue investigating to uncover city-specific clues.</p>
                </div>`;
            }
            
            container.innerHTML = html;
        }


        function renderLocationClue(clue) {
            let html = `<div class="evidence-card">`;
            
            // Turn badge
            html += `<div class="evidence-turn">Turn ${clue.turnNumber}</div>`;
            
            // Clue type and content
            switch (clue.type) {
                case 'theme':
                    html += `<div class="evidence-type">üéØ Theme</div>`;
                    html += `<div class="evidence-content">${clue.content || currentCase.theme || 'Theme revealed'}</div>`;
                    break;
                
                case 'image':
                    html += `<div class="evidence-type">üì∏ Evidence Photo</div>`;
                    
                    // Find the location image for this turn
                    const location = currentCase.locationsV2.find(loc => 
                        loc.hasImage && loc.imageTurn === clue.turnNumber
                    );
                    
                    if (location && location.imageUrl) {
                        html += `
                            <div class="evidence-image-container">
                                <img src="${location.imageUrl}" 
                                     class="evidence-image" 
                                     onclick="openEvidenceModal('${location.imageUrl}', 'Turn ${clue.turnNumber} Evidence')"
                                     title="Click to view full size">
                            </div>
                        `;
                    }
                    break;
                
                case 'breakthrough':
                    html += `<div class="evidence-type">üí° Breakthrough</div>`;
                    html += `<div class="evidence-content breakthrough">${clue.content}</div>`;
                    break;
                
                case 'pattern_recognition':
                    html += `<div class="evidence-type">üß© Pattern Recognition</div>`;
                    
                    // Parse the content to separate label from emojis
                    const content = clue.content || '';
                    const colonIndex = content.indexOf(':');
                    if (colonIndex !== -1) {
                        const label = content.substring(0, colonIndex + 1);
                        const emojiPattern = content.substring(colonIndex + 1).trim();
                        html += `<div class="evidence-content pattern-recognition">
                            <div class="pattern-label">${label}</div>
                            <div class="emoji-pattern">${emojiPattern}</div>
                        </div>`;
                    } else {
                        // Fallback if no colon found
                        html += `<div class="evidence-content pattern-recognition">
                            <div class="emoji-pattern">${content}</div>
                        </div>`;
                    }
                    break;
                
                case 'flag_colors':
                    html += `<div class="evidence-type">üè≥Ô∏è National Colors</div>`;
                    
                    // Get flag colors from final location data  
                    if (currentCase && currentCase.finalLocationV2 && currentCase.finalLocationV2.flagColors) {
                        try {
                            const flagColors = JSON.parse(currentCase.finalLocationV2.flagColors);
                            if (Array.isArray(flagColors) && flagColors.length > 0) {
                                html += `<div class="evidence-content flag-colors">
                                    <div class="flag-colors-label">Colors found in national flag:</div>
                                    <div class="flag-colors-display">`;
                                
                                flagColors.forEach(color => {
                                    html += `<div class="flag-color-swatch" style="background-color: ${color}" title="${color}"></div>`;
                                });
                                
                                html += `</div>
                                    <div class="flag-colors-description">These are the primary colors of the final location's national flag</div>
                                </div>`;
                            } else {
                                html += `<div class="evidence-content">Flag color data not available</div>`;
                            }
                        } catch (e) {
                            console.error('Error parsing flag colors:', e);
                            html += `<div class="evidence-content">Flag color data not available</div>`;
                        }
                    } else {
                        html += `<div class="evidence-content">Flag color data not available</div>`;
                    }
                    break;
                
                default:
                    html += `<div class="evidence-type">üìù Intelligence</div>`;
                    html += `<div class="evidence-content">${clue.content}</div>`;
            }
            
            // Description if available (but NOT for pattern_recognition clues)
            if (clue.description && clue.type !== 'pattern_recognition') {
                html += `<div class="evidence-description">${clue.description}</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        function openEvidenceModal(imageUrl, title) {
            document.getElementById('modalHeader').textContent = title;
            document.getElementById('modalImage').src = imageUrl;
            document.getElementById('imageModal').classList.add('show');
        }

        function closeImageModal() {
            document.getElementById('imageModal').classList.remove('show');
        }


        function showError(message) {
            document.getElementById('loadingContainer').classList.add('hidden');
            document.getElementById('errorContainer').classList.remove('hidden');
            document.getElementById('errorContainer').classList.add('show-flex');
            document.querySelector('#errorContainer p').textContent = message;
        }

        // Reuse existing modal functions from detective.html
        function showVillainModal() {
            // Implementation from original detective.html
        }

        function displayV2Turn(turnNumber) {
            // Find the turn data
            const turn = currentCase.gameplayTurns.find(t => t.turn === turnNumber);
            if (!turn) {
                console.warn(`Turn ${turnNumber} not found`);
                return;
            }
            
            // Special handling for Turn 7: Add flag colors clue
            if (turnNumber === 7 && currentCase.finalLocationV2 && currentCase.finalLocationV2.flagColors) {
                console.log('Turn 7 reached, adding flag colors clue');
                
                // Create a modified turn with flag colors clue
                const modifiedTurn = {
                    ...turn,
                    clues: [
                        ...turn.clues,
                        {
                            type: 'flag_colors',
                            content: 'Flag Colors Evidence',
                            description: 'National flag colors revealed through investigation',
                            data: {},
                            locationPositions: null
                        }
                    ]
                };
                
                // Add the modified turn to timeline
                addV2TimelineEntry(modifiedTurn);
            } else {
                // Add turn to timeline normally
                addV2TimelineEntry(turn);
            }
            
            // Show distances option when Turn 4 is reached
            if (turnNumber === 4) {
                console.log('Turn 4 reached, showing distances option');
                document.getElementById('distancesOption').style.display = 'block';
            }
            
            // Update Investigation Journal views based on current dropdown selection
            const dropdown = document.getElementById('viewDropdown');
            if (dropdown) {
                if (dropdown.value === 'distances') {
                    updateDistancesView();
                } else if (dropdown.value.startsWith('location')) {
                    const locationNum = parseInt(dropdown.value.replace('location', ''));
                    updateLocationEvidence(locationNum);
                } else if (dropdown.value === 'final') {
                    updateFinalEvidence();
                }
            }
        }

        function updateV2TurnDisplay() {
            // Update turn indicators with new styling
            for (let i = 1; i <= 7; i++) {
                const turnDot = document.getElementById(`turn${i}`);
                if (turnDot) {
                    // Remove all state classes
                    turnDot.classList.remove('active', 'past', 'current');
                    
                    if (i < currentTurn) {
                        // Past turns - green
                        turnDot.classList.add('past');
                    } else if (i === currentTurn) {
                        // Current turn - orange with glow
                        turnDot.classList.add('current');
                    }
                    // Future turns remain with default styling
                }
            }
            
            // Update progress bar
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                const progressPercent = (currentTurn / 7) * 100;
                progressFill.style.width = `${progressPercent}%`;
            }
            
            // Show final location section if we're past turn 5
            if (currentTurn > 5) {
                const finalSection = document.getElementById('finalLocationSection');
                if (finalSection) {
                    finalSection.classList.remove('hidden');
                }
            }
        }

        function addV2Turn(turn) {
            // Use the existing addV2TimelineEntry function
            addV2TimelineEntry(turn);
        }

        // View switching functions

        function updateV2LocationsView() {
            const container = document.getElementById('locationsContainer');
            if (!currentCase || !window.v2TimelineEntries) return;
            
            // Implement locations view for V2 games
            let html = '<div class="locations-grid">';
            
            // Add content for locations view
            currentCase.locationsV2.forEach((location, index) => {
                html += `<div class="location-card">
                    <h4>Location ${index + 1}</h4>
                    <p>${location.name}, ${location.country}</p>
                </div>`;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('imageModal');
            if (event.target === modal) {
                closeImageModal();
            }
        }

        // Google Authentication
        let currentUser = null;
        
        // Initialize Google Sign-In after page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Check if user is already signed in
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                updateUserUI();
                updateHeaderForUser();
            } else {
            }
        });
        
        // Initialize Google Sign-In when script loads
        async function initializeGoogleSignIn() {
            if (typeof google !== 'undefined' && google.accounts) {
                try {
                    // Fetch Google Client ID from server
                    const configResponse = await fetch('/api/config');
                    const config = await configResponse.json();
                    
                    if (config.googleClientId) {
                        google.accounts.id.initialize({
                            client_id: config.googleClientId,
                            callback: handleCredentialResponse,
                            auto_select: false,
                            cancel_on_tap_outside: true
                        });
                    } else {
                        console.error('Google Client ID not configured on server');
                    }
                } catch (error) {
                    console.error('Failed to load Google Client ID:', error);
                }
            } else {
                // Retry after a short delay if Google script hasn't loaded yet
                setTimeout(initializeGoogleSignIn, 100);
            }
        }
        
        // Start initialization
        initializeGoogleSignIn();
        
        function signIn() {
            if (typeof google === 'undefined' || !google.accounts) {
                console.error('Google Sign-In not loaded');
                alert('Google Sign-In is not available. Please try refreshing the page.');
                return;
            }
            
            // Skip One Tap and go directly to popup to avoid FedCM issues
            renderSignInButton();
        }
        
        function renderSignInButton() {
            // Create a temporary container for the sign-in button
            const tempContainer = document.createElement('div');
            tempContainer.id = 'tempSignInContainer';
            tempContainer.className = 'sign-in-modal-container';
            
            tempContainer.innerHTML = `
                <h3 class="sign-in-modal-title">Sign In to Worldwide Chase</h3>
                <div id="googleSignInButton"></div>
                <button onclick="closeSignInModal()" class="sign-in-cancel-button">Cancel</button>
            `;
            
            document.body.appendChild(tempContainer);
            
            // Render Google Sign-In button
            google.accounts.id.renderButton(
                document.getElementById('googleSignInButton'),
                {
                    theme: 'outline',
                    size: 'large',
                    text: 'signin_with',
                    shape: 'rectangular'
                }
            );
        }
        
        function closeSignInModal() {
            const modal = document.getElementById('tempSignInContainer');
            if (modal) {
                modal.remove();
            }
        }
        
        function handleCredentialResponse(response) {
            // Close sign-in modal if open
            closeSignInModal();
            
            // Decode JWT token
            const responsePayload = decodeJwtResponse(response.credential);
            
            const googleUser = {
                id: responsePayload.sub,
                fullName: responsePayload.name,
                email: responsePayload.email,
                picture: responsePayload.picture,
                firstName: responsePayload.given_name || responsePayload.name.split(' ')[0]
            };
            
            // Check if this is a new user
            const existingUser = localStorage.getItem(`user_${googleUser.id}`);
            
            if (!existingUser) {
                // New user - show signup modal
                showSignupModal(googleUser);
            } else {
                // Existing user - load their profile
                currentUser = JSON.parse(existingUser);
                // Update with latest Google info
                currentUser.fullName = googleUser.fullName;
                currentUser.email = googleUser.email;
                currentUser.picture = googleUser.picture;
                
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                localStorage.setItem(`user_${currentUser.id}`, JSON.stringify(currentUser));
                
                updateUserUI();
                savePendingGameResult();
            }
        }
        
        function showSignupModal(googleUser) {
            const modal = document.createElement('div');
            modal.id = 'signupModal';
            modal.className = 'signup-modal';
            
            modal.innerHTML = `
                <div class="signup-modal-content">
                    <h2 class="signup-modal-title">Welcome to Worldwide Chase!</h2>
                    <p class="signup-modal-text">Choose a username for your detective profile:</p>
                    
                    <div class="signup-input-container">
                        <label class="signup-input-label">Username:</label>
                        <input type="text" id="usernameInput" value="${googleUser.firstName}" class="signup-input" maxlength="20" placeholder="Enter username">
                        <small class="signup-input-hint">This will be displayed on leaderboards and your profile</small>
                    </div>
                    
                    <div class="signup-button-container">
                        <button onclick="completeSignup()" class="signup-button">Start Playing</button>
                        <button onclick="cancelSignup()" class="signup-cancel-button">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Store google user data temporarily
            window.tempGoogleUser = googleUser;
            
            // Focus on username input
            setTimeout(() => {
                const input = document.getElementById('usernameInput');
                input.focus();
                input.select();
                
                // Allow Enter key to complete signup
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        completeSignup();
                    }
                });
            }, 100);
        }
        
        function completeSignup() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            const googleUser = window.tempGoogleUser;
            
            currentUser = {
                id: googleUser.id,
                username: username,
                fullName: googleUser.fullName,
                email: googleUser.email,
                picture: googleUser.picture,
                joinedAt: new Date().toISOString()
            };
            
            // Save user profile
            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            localStorage.setItem(`user_${currentUser.id}`, JSON.stringify(currentUser));
            
            // Close modal
            closeSignupModal();
            
            // Update UI
            updateUserUI();
            
            // Save any pending game results
            savePendingGameResult();
            
            // Clean up temp data
            delete window.tempGoogleUser;
        }
        
        function cancelSignup() {
            closeSignupModal();
            delete window.tempGoogleUser;
        }
        
        function closeSignupModal() {
            const modal = document.getElementById('signupModal');
            if (modal) {
                modal.remove();
            }
        }
        
        function decodeJwtResponse(token) {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        }
        
        function updateUserUI() {
            const userMenuText = document.getElementById('userMenuText');
            const signedOutMenu = document.getElementById('signedOutMenu');
            const signedInMenu = document.getElementById('signedInMenu');
            const menuUserName = document.getElementById('menuUserName');
            
            // Safety check - if header elements aren't loaded yet, return early
            if (!userMenuText || !signedOutMenu || !signedInMenu) {
                return;
            }
            
            if (currentUser) {
                // Update button text to show username
                userMenuText.textContent = currentUser.username || currentUser.name || currentUser.fullName;
                
                // Show signed-in menu, hide signed-out menu
                signedOutMenu.classList.add('hidden');
                signedInMenu.classList.remove('hidden');
                signedInMenu.classList.add('show');
                
                // Update user name in menu
                if (menuUserName) {
                    menuUserName.textContent = `Detective ${currentUser.username || currentUser.name || currentUser.fullName}`;
                }
                
                // Update end game modal if it's currently shown
                updateEndGameModalSignInStatus();
            } else {
                // Show "Sign In" text
                userMenuText.textContent = 'Sign In';
                
                // Show signed-out menu, hide signed-in menu
                signedOutMenu.classList.remove('hidden');
                signedOutMenu.classList.add('show');
                signedInMenu.classList.add('hidden');
            }
        }
        
        async function savePendingGameResult() {
            // Check if there's a pending result to save
            const pendingResult = sessionStorage.getItem('pendingGameResult');
            if (pendingResult && currentUser) {
                const result = JSON.parse(pendingResult);
                result.userId = currentUser.id;
                result.userName = currentUser.name;
                
                try {
                    // TODO: Send to server API when implemented
                    // await fetch('/api/results', {
                    //     method: 'POST',
                    //     headers: { 'Content-Type': 'application/json' },
                    //     body: JSON.stringify(result)
                    // });
                    
                    // For now, save to localStorage with size limits
                    const MAX_RESULTS = 100; // Prevent memory bloat
                    const userResults = JSON.parse(localStorage.getItem(`userResults_${currentUser.id}`) || '[]');
                    userResults.push(result);
                    
                    // Keep only the most recent results
                    if (userResults.length > MAX_RESULTS) {
                        userResults.splice(0, userResults.length - MAX_RESULTS);
                    }
                    
                    localStorage.setItem(`userResults_${currentUser.id}`, JSON.stringify(userResults));
                    
                    sessionStorage.removeItem('pendingGameResult');
                } catch (error) {
                    console.error('Error saving game result:', error);
                }
            }
        }

        // User Menu Functions
        function toggleUserMenu() {
            const button = document.getElementById('userMenuButton');
            const dropdown = document.getElementById('userMenuDropdown');
            const isOpen = !dropdown.classList.contains('hidden');
            
            if (isOpen) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            } else {
                dropdown.classList.remove('hidden');
                dropdown.classList.add('show');
                button.classList.add('open');
            }
        }

        // Close user menu when clicking outside
        document.addEventListener('click', function(event) {
            const userMenuContainer = document.getElementById('userMenuContainer');
            if (userMenuContainer && !userMenuContainer.contains(event.target)) {
                const dropdown = document.getElementById('userMenuDropdown');
                const button = document.getElementById('userMenuButton');
                if (dropdown && !dropdown.classList.contains('hidden')) {
                    dropdown.classList.add('hidden');
                    dropdown.classList.remove('show');
                    button.classList.remove('open');
                }
            }
        });

        // Help Modal Functions
        function showHelpModal() {
            document.getElementById('helpModal').classList.add('show');
            // Close user menu if open
            const dropdown = document.getElementById('userMenuDropdown');
            const button = document.getElementById('userMenuButton');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            }
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('show');
        }

        // Close help modal when clicking outside
        const helpModal = document.getElementById('helpModal');
        if (helpModal) {
            helpModal.addEventListener('click', function(event) {
                if (event.target === this) {
                    closeHelpModal();
                }
            });
        }

        // Close modals with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const helpModal = document.getElementById('helpModal');
                const profileModal = document.getElementById('profileModal');
                if (helpModal.classList.contains('show')) {
                    closeHelpModal();
                }
                if (profileModal.classList.contains('show')) {
                    closeProfileModal();
                }
            }
        });

        // Profile Modal Functions
        function showProfileModal() {
            updateProfileDisplay();
            document.getElementById('profileModal').classList.add('show');
            // Close user menu if open
            const dropdown = document.getElementById('userMenuDropdown');
            const button = document.getElementById('userMenuButton');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            }
        }

        function closeProfileModal() {
            document.getElementById('profileModal').classList.remove('show');
        }

        // Close profile modal when clicking outside (with safety check)
        setTimeout(() => {
            const profileModal = document.getElementById('profileModal');
            if (profileModal) {
                profileModal.addEventListener('click', function(event) {
                    if (event.target === this) {
                        closeProfileModal();
                    }
                });
            }
        }, 100);

        function updateProfileDisplay() {
            const editButton = document.getElementById('editUsernameBtn');
            
            if (currentUser) {
                // Show username instead of full name
                document.getElementById('profileUserName').textContent = currentUser.username || currentUser.name || currentUser.fullName;
                document.getElementById('profileUserEmail').textContent = currentUser.email || '';
                
                // Show edit button when user is logged in
                editButton.classList.remove('hidden');
                
                // Get user stats
                const userResults = JSON.parse(localStorage.getItem(`userResults_${currentUser.id}`) || '[]');
                const casesPlayed = userResults.length;
                
                document.getElementById('profileCasesPlayed').textContent = `Cases Solved: ${casesPlayed}`;
                
                if (casesPlayed > 0) {
                    const averageScore = Math.round(userResults.reduce((sum, result) => sum + result.score, 0) / casesPlayed);
                    const bestTime = Math.min(...userResults.map(result => result.timeTaken));
                    const bestTimeMinutes = Math.floor(bestTime / 60);
                    const bestTimeSeconds = bestTime % 60;
                    
                    document.getElementById('profileAverageScore').textContent = `Average Score: ${averageScore}`;
                    document.getElementById('profileBestTime').textContent = `Best Time: ${bestTimeMinutes}m ${bestTimeSeconds}s`;
                } else {
                    document.getElementById('profileAverageScore').textContent = 'Average Score: N/A';
                    document.getElementById('profileBestTime').textContent = 'Best Time: N/A';
                }
            } else {
                document.getElementById('profileUserName').textContent = 'Sign in to track your progress';
                document.getElementById('profileUserEmail').textContent = 'N/A';
                document.getElementById('profileCasesPlayed').textContent = 'Cases Solved: 0';
                document.getElementById('profileAverageScore').textContent = 'Average Score: N/A';
                document.getElementById('profileBestTime').textContent = 'Best Time: N/A';
                
                // Hide edit button when not logged in
                editButton.classList.add('hidden');
            }
        }

        // Sign out function
        function signOut() {
            currentUser = null;
            localStorage.removeItem('currentUser');
            updateUserUI();
            // Close user menu
            const dropdown = document.getElementById('userMenuDropdown');
            const button = document.getElementById('userMenuButton');
            if (dropdown) {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('show');
                button.classList.remove('open');
            }
        }

        // Edit Username Modal Functions
        function showEditUsernameModal() {
            if (!currentUser) return;
            
            const modal = document.getElementById('editUsernameModal');
            const input = document.getElementById('usernameEditInput');
            
            // Pre-fill with current username
            input.value = currentUser.username || currentUser.name || currentUser.fullName;
            
            modal.classList.add('show');
            
            // Focus and select the input
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }

        function closeEditUsernameModal() {
            document.getElementById('editUsernameModal').classList.remove('show');
        }

        function saveUsername() {
            const newUsername = document.getElementById('usernameEditInput').value.trim();
            
            if (!newUsername) {
                alert('Please enter a username');
                return;
            }
            
            if (newUsername.length < 2) {
                alert('Username must be at least 2 characters long');
                return;
            }
            
            if (newUsername.length > 20) {
                alert('Username must be 20 characters or less');
                return;
            }
            
            // Update current user
            currentUser.username = newUsername;
            
            // Save to localStorage
            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            localStorage.setItem(`user_${currentUser.id}`, JSON.stringify(currentUser));
            
            // Update UI
            updateUserUI();
            updateProfileDisplay();
            
            // Close modal
            closeEditUsernameModal();
        }

        // Close edit username modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('editUsernameModal');
            if (event.target === modal) {
                closeEditUsernameModal();
            }
        });

        // Allow Enter key to save username
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                const modal = document.getElementById('editUsernameModal');
                if (modal.classList.contains('show')) {
                    saveUsername();
                }
            }
        });

        // Villain Modal Functions
        function showVillainModal() {
            if (!gameData) return;
            
            const modal = document.getElementById('villainModal');
            const villainImage = document.getElementById('villainModalImage');
            const villainName = document.getElementById('villainModalName');
            const villainTitle = document.getElementById('villainModalTitle');
            
            // Set villain information
            villainImage.src = gameData.villainImageUrl || '/game/wwc-logo.png';
            villainName.textContent = gameData.villainName || 'Unknown Suspect';
            villainTitle.textContent = gameData.villainTitle || 'Criminal Mastermind';
            
            modal.classList.add('show');
        }

        function closeVillainModal() {
            document.getElementById('villainModal').classList.remove('show');
        }

        // Close villain modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('villainModal');
            if (event.target === modal) {
                closeVillainModal();
            }
        });

        // Add Escape key handler for villain modal
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const villainModal = document.getElementById('villainModal');
                if (villainModal && villainModal.classList.contains('show')) {
                    closeVillainModal();
                }
            }
        });

        // Comprehensive cleanup system for memory leak prevention
        let eventListeners = [];
        
        // Store references to event listeners for cleanup
        function addEventListenerWithCleanup(element, event, handler, options = false) {
            element.addEventListener(event, handler, options);
            eventListeners.push({ element, event, handler, options });
        }
        
        // Cleanup function to remove all event listeners
        function cleanupEventListeners() {
            eventListeners.forEach(({ element, event, handler, options }) => {
                try {
                    element.removeEventListener(event, handler, options);
                } catch (e) {
                    console.warn('Failed to remove event listener:', e);
                }
            });
            eventListeners = [];
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            // Clear timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Clear event listeners
            cleanupEventListeners();
            
            // Clear global arrays
            if (window.v2TimelineEntries) {
                window.v2TimelineEntries = [];
            }
            
            console.log('üßπ Detective game cleanup completed');
        });
        
        // Alternative cleanup for navigation
        window.addEventListener('pagehide', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            cleanupEventListeners();
        });
    </script>

    <!-- Help Modal -->
    <div id="helpModal" class="help-modal">
        <div class="help-modal-content">
            <button class="help-close" onclick="closeHelpModal()">&times;</button>
            <div class="help-modal-header">How to Play</div>
            <div class="help-content">
                <div class="help-section">
                    <h3>üîç Your Mission</h3>
                    <p>Track a criminal across the globe. Identify <strong>3 crime scene locations + 1 final hideout</strong> to capture the suspect.</p>
                </div>

                <div class="help-section">
                    <h3>üé≤ How It Works</h3>
                    <p><strong>Turns 1-5:</strong> Use clues, photos, and geographic data to identify the 3 crime scene locations</p>
                    <p><strong>Turns 6-7:</strong> Deduce the final hideout location to capture the suspect</p>
                </div>

                <div class="help-section">
                    <h3>üïµÔ∏è Detective Tools</h3>
                    <ul>
                        <li><strong>Investigation Journal:</strong> Organize evidence by timeline or location</li>
                        <li><strong>Evidence Photos:</strong> Click images for full-size examination</li>
                        <li><strong>Check Answers:</strong> Submit guesses and track progress</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>üèÜ Leaderboard</h3>
                    <p>Compete across difficulty levels. Score based on locations identified, difficulty, and time.</p>
                    <p>Sign in to access rankings and track your detective record.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profileModal" class="profile-modal">
        <div class="profile-modal-content">
            <button class="profile-close" onclick="closeProfileModal()">&times;</button>
            <div class="profile-modal-header">Detective Profile</div>
            <div class="profile-content">
                <div class="help-section">
                    <h3>üë§ Account Details</h3>
                    <div class="profile-field">
                        <span><strong>Username:</strong> <span id="profileUserName">Sign in to track your progress</span></span>
                        <button id="editUsernameBtn" class="edit-button hidden" onclick="showEditUsernameModal()">Edit</button>
                    </div>
                    <div class="profile-field">
                        <span><strong>Email:</strong> <span id="profileUserEmail">N/A</span></span>
                    </div>
                </div>

                <div class="help-section">
                    <h3>üìä Detective Stats</h3>
                    <p id="profileCasesPlayed">Cases Solved: 0</p>
                    <p id="profileAverageScore">Average Score: N/A</p>
                    <p id="profileBestTime">Best Time: N/A</p>
                </div>

                <div class="help-section">
                    <h3>üéñÔ∏è Achievements</h3>
                    <p>Coming soon - Track your detective accomplishments!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Username Modal -->
    <div id="editUsernameModal" class="edit-username-modal">
        <div class="edit-username-content">
            <div class="edit-username-header">Edit Username</div>
            <input type="text" id="usernameEditInput" class="username-input" placeholder="Enter new username" maxlength="20">
            <div class="edit-username-buttons">
                <button class="save-username-btn" onclick="saveUsername()">Save</button>
                <button class="cancel-username-btn" onclick="closeEditUsernameModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Villain Image Modal -->
    <div id="villainModal" class="villain-modal">
        <div class="villain-modal-content">
            <button class="villain-modal-close" onclick="closeVillainModal()">&times;</button>
            <div class="villain-modal-header">Suspect Profile</div>
            <img id="villainModalImage" class="villain-modal-image" src="" alt="Villain Portrait">
            <div class="villain-modal-info">
                <div id="villainModalName" class="villain-modal-name"></div>
                <div id="villainModalTitle" class="villain-modal-title"></div>
            </div>
        </div>
    </div>

    <!-- End Game Modal -->
    <div id="endGameModal" class="image-modal">
        <div class="modal-content end-game-modal-content">
            <div class="modal-header" id="endGameHeader">CASE CLOSED</div>
            <div id="endGameContent" class="end-game-content">
                <!-- Content will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Detective Header Partial -->
    <script src="detective-header.js"></script>

</body>
</html>